<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Mspace-checkins] r599 - in twittinho: . bin data data/images lib	lib/twittinho
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/mspace-checkins/2007-June/index.html" >
   <LINK REL="made" HREF="mailto:mspace-checkins%40lists.berlios.de?Subject=Re%3A%20%5BMspace-checkins%5D%20r599%20-%20in%20twittinho%3A%20.%20bin%20data%20data/images%20lib%0A%09lib/twittinho&In-Reply-To=%3C200706040116.l541GAF1016346%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000310.html">
   <LINK REL="Next"  HREF="000312.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mspace-checkins] r599 - in twittinho: . bin data data/images lib	lib/twittinho</H1>
    <B>luis at mail.berlios.de</B> 
    <A HREF="mailto:mspace-checkins%40lists.berlios.de?Subject=Re%3A%20%5BMspace-checkins%5D%20r599%20-%20in%20twittinho%3A%20.%20bin%20data%20data/images%20lib%0A%09lib/twittinho&In-Reply-To=%3C200706040116.l541GAF1016346%40sheep.berlios.de%3E"
       TITLE="[Mspace-checkins] r599 - in twittinho: . bin data data/images lib	lib/twittinho">luis at mail.berlios.de
       </A><BR>
    <I>Mon Jun  4 03:16:10 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000310.html">[Mspace-checkins] r598 - twittinho
</A></li>
        <LI>Next message: <A HREF="000312.html">[Mspace-checkins] r600 - twittinho
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#311">[ date ]</a>
              <a href="thread.html#311">[ thread ]</a>
              <a href="subject.html#311">[ subject ]</a>
              <a href="author.html#311">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: luis
Date: 2007-06-04 03:15:49 +0200 (Mon, 04 Jun 2007)
New Revision: 599

Added:
   twittinho/AUTHORS
   twittinho/bin/
   twittinho/bin/twittinho
   twittinho/data/
   twittinho/data/images/
   twittinho/data/images/default_face.png
   twittinho/lib/
   twittinho/lib/twittinho.rb
   twittinho/lib/twittinho/
   twittinho/lib/twittinho/gui.rb
   twittinho/lib/twittinho/model.rb
   twittinho/lib/twittinho/nucleo.rb
   twittinho/setup.rb
Removed:
   twittinho/LEEME
   twittinho/controller.rb
   twittinho/gui.rb
   twittinho/model.rb
   twittinho/nucleo.rb
Log:
Cambios de estructura de los fuentes


Added: twittinho/AUTHORS
===================================================================
--- twittinho/AUTHORS	2007-06-03 22:21:54 UTC (rev 598)
+++ twittinho/AUTHORS	2007-06-04 01:15:49 UTC (rev 599)
@@ -0,0 +1,2 @@
+Developer:
+Luis Bosque &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/mspace-checkins">luisico at gmail.com</A>&gt;

Deleted: twittinho/LEEME
===================================================================
--- twittinho/LEEME	2007-06-03 22:21:54 UTC (rev 598)
+++ twittinho/LEEME	2007-06-04 01:15:49 UTC (rev 599)
@@ -1,19 +0,0 @@
-Las dependencias de este software son las siguientes:
-
-* ruby-gnome2 &gt;= 0.16
-* ruby-libnotify &gt;= 0.32
-* Bindng de twitter en ruby (<A HREF="http://rubyforge.org/projects/twitter/">http://rubyforge.org/projects/twitter/</A>)
-
-Este software todav&#237;a est&#225; en su versi&#243;n Alpha. Es usable, solo que requiere algunos cuidados para ejecutarlo.
-Para iniciar el software hay que ejecutar lo siguiente:
-
-$ ruby controller.rb
-
-Cualquier duda, bug, comentario o sugerencia, por favor, comentar en la siguiente p&#225;gina:
-
-<A HREF="http://lbosque.wordpress.com/twittinho/">http://lbosque.wordpress.com/twittinho/</A>
-
-En esa misma p&#225;gina se puede encontrar la informaci&#243;n del proyecto.
-
-
-

Copied: twittinho/bin/twittinho (from rev 598, twittinho/controller.rb)
===================================================================
--- twittinho/controller.rb	2007-06-03 22:21:54 UTC (rev 598)
+++ twittinho/bin/twittinho	2007-06-04 01:15:49 UTC (rev 599)
@@ -0,0 +1,33 @@
+#! /usr/bin/ruby1.8
+
+$KCODE = 'u'
+
+require 'gconf2'
+require 'twittinho'
+
+gconfPath = &quot;/apps/twitinho/&quot;
+client = GConf::Client.default
+
+if client.dir_exists?(gconfPath.chomp(&quot;\/&quot;))
+	config = readConfig(client)
+else
+	writeConfig(client, gconfPath, &quot;user&quot;, &quot;pass&quot;, 2, true )
+end
+
+initState = true
+
+nucleo = Nucleo.new(config)
+mainWindow = MainWindow.new(nucleo, config)
+statusIcon = StatusIcon.new(mainWindow, client)
+
+
+thread = Thread.new do
+        loop {
+		nucleo.refreshStatuses(statusIcon, initState, config)
+		initState = false
+		sleep(config[&quot;refresh&quot;])
+	}
+end
+
+Gtk.main
+

Deleted: twittinho/controller.rb
===================================================================
--- twittinho/controller.rb	2007-06-03 22:21:54 UTC (rev 598)
+++ twittinho/controller.rb	2007-06-04 01:15:49 UTC (rev 599)
@@ -1,33 +0,0 @@
-$KCODE = 'u'
-
-require 'gconf2'
-require 'gui'
-require 'model'
-require 'nucleo'
-
-gconfPath = &quot;/apps/twitinho/&quot;
-client = GConf::Client.default
-
-if client.dir_exists?(gconfPath.chomp(&quot;\/&quot;))
-	config = readConfig(client)
-else
-	writeConfig(client, gconfPath, &quot;user&quot;, &quot;pass&quot;, 2, true )
-end
-
-initState = true
-
-nucleo = Nucleo.new(config)
-mainWindow = MainWindow.new(nucleo, config)
-statusIcon = StatusIcon.new(mainWindow, client)
-
-
-thread = Thread.new do
-        loop {
-		nucleo.refreshStatuses(statusIcon, initState, config)
-		initState = false
-		sleep(config[&quot;refresh&quot;])
-	}
-end
-
-Gtk.main
-

Added: twittinho/data/images/default_face.png
===================================================================
(Binary files differ)


Property changes on: twittinho/data/images/default_face.png
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Deleted: twittinho/gui.rb
===================================================================
--- twittinho/gui.rb	2007-06-03 22:21:54 UTC (rev 598)
+++ twittinho/gui.rb	2007-06-04 01:15:49 UTC (rev 599)
@@ -1,245 +0,0 @@
-$KCODE = 'u'
-
-require 'gtk2'
-require 'libnotify'
-
-class MainWindow &lt; Gtk::Window
-
-	def initialize (nucleo, config)
-		
-		@pixbufRend = Gtk::CellRendererPixbuf.new()
-
-		@textRend = Gtk::CellRendererText.new()
-		@textRend.set_property('wrap_mode', Pango::Layout::WRAP_WORD_CHAR)
-		@textRend.set_single_paragraph_mode(false)
-		@textRend.set_width(50)
-
-		@imageCol = Gtk::TreeViewColumn.new(&quot;Cara&quot;, @pixbufRend, :pixbuf =&gt; 0)
-		@imageCol.set_resizable(false)
-		@imageCol.set_spacing(5)
-		
-		@textCol = Gtk::TreeViewColumn.new(&quot;Nombre&quot;, @textRend, :markup =&gt; 1)
-		@textCol.set_resizable(true)
-		@textCol.set_fixed_width(500)
-		@textCol.set_sizing(Gtk::TreeViewColumn::FIXED)
-		@textCol.set_spacing(20)
-		
-		@listView = Gtk::TreeView.new()
-		@listView.set_model(nucleo.listStore)
-		@listView.append_column(@imageCol)
-		@listView.append_column(@textCol)
-		@listView.headers_visible = false
-		@listView.rules_hint = true
-
-		@scrolledWindow = Gtk::ScrolledWindow.new()
-		@scrolledWindow.set_policy(Gtk::POLICY_NEVER, Gtk::POLICY_AUTOMATIC)
-		@scrolledWindow.add(@listView)
-
-		@vBox = Gtk::VBox.new()
-		@vBox.set_spacing(6)
-		@vBox.add(@scrolledWindow)
-
-		@btnHome = Gtk::Button.new(Gtk::Stock::HOME)
-		@btnHome.set_relief(Gtk::RELIEF_HALF)
-		@btnHome.signal_connect( &quot;clicked&quot; ) { |w| 
-			system(&quot;gnome-open <A HREF="http://twitter.com/#{config[">http://twitter.com/#{config[</A>'user']}&quot;)
-		}
-		
-		@entry = Gtk::Entry.new
-		@entry.max_length = 140
-		@entry.signal_connect( &quot;changed&quot; ) { |w|OnPostEntryChanged(w, @labelCarac) }
-		@entry.signal_connect( &quot;activate&quot; ) { |w| OnPostEntryActivated(w, nucleo.connection) }
-		
-		@labelCarac = Gtk::Label.new(&quot;140&quot;)
-		
-		@hBox = Gtk::HBox.new
-		
-		@hBox.pack_start(@btnHome, expand=false)
-		@hBox.add(@entry)
-		@hBox.pack_start(@labelCarac, expand=false)
-		
-		@vBox.pack_start(@hBox, expand=false)
-		
-		@statusBar = Gtk::Statusbar.new
-		
-		@vBox.pack_start(@statusBar, expand=false)
-
-		super()
-		
-		set_title(&quot;Twitinho Alpha 0.2&quot;)		
-		set_default_size(300, 500)
-                set_border_width(6)
-		resizable = false
-		signal_connect(&quot;delete_event&quot;) { Gtk.main_quit; exit! }
-		add(@vBox)
-
-		show_all
-
-	end		
-
-	def getListView
-		return @listView
-	end
-
-	def OnPostEntryChanged(texto,label)
-	        label.text = (140 - texto.text.length).to_s
-	end
-	
-	def OnPostEntryActivated(entry, connection)
-		entry.editable = false
-		connection.update(entry.text)
-		entry.text = &quot;&quot;
-		entry.editable = true
-	end
-	
-
-end
-
-class StatusMenu &lt; Gtk::Menu
-
-	def initialize (client)
-		#refreshItem = Gtk::ImageMenuItem.new(Gtk::Stock::REFRESH)
-		#refreshItem.signal_connect(&quot;activate&quot;) { Thread.new { nucleo.refreshStatuses } }
-		#refreshItem.show
-		
-		preferencesItem = Gtk::ImageMenuItem.new(Gtk::Stock::PREFERENCES)
-		preferencesItem.signal_connect(&quot;activate&quot;) { WindowPreferences.new(client, true) }
-		preferencesItem.show
-		
-		quitItem = Gtk::ImageMenuItem.new(Gtk::Stock::QUIT)
-		quitItem.signal_connect(&quot;activate&quot;) { Gtk.main_quit }
-		quitItem.show
-		
-		
-		super()
-
-		#add(refreshItem)
-		add(preferencesItem)
-		add(quitItem)
-	end
-end
-
-class StatusIcon &lt; Gtk::StatusIcon
-
-	def initialize(window, client)
-		@menu = StatusMenu.new(client)
-		super()
-		
-		set_icon_name(Gtk::Stock::HOME)
-		set_tooltip(&quot;Twitinho&quot;)
-		signal_connect(&quot;popup_menu&quot;) { |w, button, time| OnStatusIconPopUp(w, button, time, @menu) }
-		signal_connect(&quot;activate&quot;) { |w, button, time| OnStatusIconActivated(w, window) }
-	end	
-	
-	def OnStatusIconPopUp (w, button, time, menu)
-	        menu.popup(nil, nil, button, time)
-	
-	end
-	
-	def OnStatusIconActivated (w, window)
-		if window.visible?
-			window.hide
-		else
-			window.show
-		end
-	end
-end
-
-
-
-class WindowPreferences &lt; Gtk::Window
-
-	def initialize (client, configState)
-		if configState
-			config = readConfig(client)		
-		else
-			config = Hash.new
-			config[&quot;user&quot;] = &quot;&quot;
-			config[&quot;password&quot;] = &quot;&quot;
-			config[&quot;refresh&quot;] = 120
-			config[&quot;notifications&quot;] = false
-		end
-
-		labelAuthentication = Gtk::Label.new()
-		labelAuthentication.set_markup('&lt;b&gt;Authentication&lt;/b&gt;')
-		
-		labelUser = Gtk::Label.new('Username')
-		
-		entryUser = Gtk::Entry.new()
-		entryUser.set_text(config[&quot;user&quot;])
-		
-		labelPassword = Gtk::Label.new('Password')
-		
-		entryPassword = Gtk::Entry.new()
-		entryPassword.set_visibility(false)
-		entryPassword.set_text(config[&quot;password&quot;])
-		
-		
-		labelOthers = Gtk::Label.new()
-		labelOthers.set_markup('&lt;b&gt;Others&lt;/b&gt;')
-		labelOthers.set_justify(Gtk::JUSTIFY_LEFT)
-		
-		checkButtonNotifications = Gtk::CheckButton.new('Active Notifications?')
-		checkButtonNotifications.set_active(config[&quot;notifications&quot;])	
-		
-		refreshLabel = Gtk::Label.new('States Refresh Time (in seconds)')
-
-		refreshEntry = Gtk::Entry.new()
-		refreshEntry.set_text(config[&quot;refresh&quot;].to_s)
-		acceptButton = Gtk::Button.new(Gtk::Stock::OK)
-		acceptButton.signal_connect(&quot;clicked&quot;) {
-			OnAcceptButtonClicked(client, entryUser, entryPassword, checkButtonNotifications, refreshEntry) 
-			destroy	
-		}
-		cancelButton = Gtk::Button.new(Gtk::Stock::CANCEL)
-		cancelButton.signal_connect(&quot;clicked&quot;) { destroy }
-		
-		hButtonBox = Gtk::HButtonBox.new()
-		hButtonBox.pack_start(cancelButton, padding = 5)	
-		hButtonBox.pack_start(acceptButton, padding = 5)	
-		hButtonBox.set_layout_style(Gtk::ButtonBox::Style::END)
-		hButtonBox.set_spacing(20)
-		
-		
-		table = Gtk::Table.new(7,4,homogeneus = false)
-		
-		table.attach(labelAuthentication, 1, 2, 1, 2, Gtk::FILL, Gtk::FILL, 8, 8)
-		table.attach(labelUser, 1, 2, 2, 3, Gtk::FILL, Gtk::FILL, 8, 8)
-		table.attach(entryUser, 2, 3, 2, 3, Gtk::FILL, Gtk::FILL, 8, 8)
-		table.attach(labelPassword, 1, 2, 3, 4, Gtk::FILL, Gtk::FILL, 8, 8)
-		table.attach(entryPassword, 2, 3, 3, 4, Gtk::FILL, Gtk::FILL, 8, 8)
-		table.attach(labelOthers, 1, 2, 4, 5, Gtk::FILL, Gtk::FILL, 8, 8)
-		table.attach(checkButtonNotifications, 1, 3, 5, 6, Gtk::FILL, Gtk::FILL, 8, 8)
-		table.attach(refreshLabel, 1, 2, 6, 7, Gtk::FILL, Gtk::FILL, 8, 8)
-		table.attach(refreshEntry, 2, 3, 6, 7, Gtk::FILL, Gtk::FILL, 8, 8)
-		
-		vbox = Gtk::VBox.new()
-		vbox.add(table)
-		vbox.add(hButtonBox)
-		vbox.set_spacing(6)		
-	
-		super()		
-		set_title(&quot;Preferences&quot;)	
-		set_default_size(320, 250)
-		set_border_width(6)
-		set_resizable = false
-		set_modal(true)
-		signal_connect(&quot;delete_event&quot;) { destroy }
-		
-		add(vbox)
-		show_all
-	end
-	
-	def OnAcceptButtonClicked (client, user, password, notifications, refresh)
-		config = Hash.new
-		config[&quot;user&quot;] = user.text	
-		config[&quot;password&quot;] = password.text
-		config[&quot;notifications&quot;] = notifications.active?
-		config[&quot;refresh&quot;] = refresh.text
-		writeConfig(client, config)
-	end
-
-	
-	
-
-end

Copied: twittinho/lib/twittinho/gui.rb (from rev 596, twittinho/gui.rb)

Copied: twittinho/lib/twittinho/model.rb (from rev 596, twittinho/model.rb)

Copied: twittinho/lib/twittinho/nucleo.rb (from rev 596, twittinho/nucleo.rb)
===================================================================
--- twittinho/nucleo.rb	2007-06-03 15:24:24 UTC (rev 596)
+++ twittinho/lib/twittinho/nucleo.rb	2007-06-04 01:15:49 UTC (rev 599)
@@ -0,0 +1,93 @@
+$KCODE = 'u'
+
+require 'gtk2'
+require 'twitter'
+require 'curb'
+require 'fileutils'
+
+class Nucleo
+
+	def initialize(config)
+		@connection = connect(config[&quot;user&quot;], config[&quot;password&quot;])
+		@lastStatusID = 0
+		@listStore = Gtk::ListStore.new(Gdk::Pixbuf, String)
+	end
+
+	def setLastStatusId(statusID)
+		@lastStatusID = statusID
+	end
+
+	def connection
+		@connection
+	end
+		
+	def listStore
+		@listStore
+	end
+
+	def checkNewStates
+        	return @connection.timeline(:friends)
+	end
+
+	def refreshStatuses(statusIcon, initState, config)
+        	statusesToUpdate = updateStatus
+        	if !statusesToUpdate.empty?
+        	        statusesToUpdate.each do |state|
+        	                getFaces(state.user)
+        	                insertState(state)
+        	                sendNotify(state.user, state.text, statusIcon) if config[&quot;notifications&quot;] &amp;&amp; ! initState
+        	                setLastStatusId(state.id)
+        	        end
+        	end
+	end
+
+	def updateStatus
+		newStates = checkNewStates
+		newStates = newStates.reverse!
+                statesArray = Array.new
+		newStates.each do |state|
+                	if state.id.to_i &gt; @lastStatusID.to_i
+				statesArray &lt;&lt; state
+			end
+		end
+		return statesArray
+	end
+
+	def insertState(state)
+        	## Rows are been inserted at the first position on the model. Surely it could be improved.
+        	iter = @listStore.insert(0)
+        	iter[0] = Gdk::Pixbuf.new(face(state.user.screen_name))
+        	iter[1] = state.text
+		@lastStatusID = state.id
+		#if listStore.get_iter(Gtk::TreePath.new(19))
+                #	listStore.remove(listStore.get_iter(Gtk::TreePath.new(19)))
+                #end
+
+	end
+
+	def face(twitterUser)
+		return ENV['HOME'] + '/.twitinho/images/' +  twitterUser + '.png'
+	end
+	
+	def getFaces(user)
+        	if File.exist?(face(user.screen_name))
+        	        return
+        	else
+			from = ENV['HOME'] + '/.twitinho/default_face.png'
+			FileUtils.copy(from, face(user.screen_name))
+			Thread.new do
+	        	        sleep(1)
+				url = user.profile_image_url
+        		        Curl::Easy.download(url, face(user.screen_name))
+			end
+        	end
+	end
+
+	def sendNotify(user, state, statusIcon) 
+                LibNotify.init( &quot;Twittinho&quot; )
+		test = LibNotify::Notification.new(user.name, state, face(user.screen_name), statusIcon)
+                test.timeout= 10000      # 5 seconds
+                test.show
+	end
+	
+end

Added: twittinho/lib/twittinho.rb
===================================================================
--- twittinho/lib/twittinho.rb	2007-06-03 22:21:54 UTC (rev 598)
+++ twittinho/lib/twittinho.rb	2007-06-04 01:15:49 UTC (rev 599)
@@ -0,0 +1,4 @@
+require 'twittinho/gui'
+require 'twittinho/model'
+require 'twittinho/nucleo'
+

Deleted: twittinho/model.rb
===================================================================
--- twittinho/model.rb	2007-06-03 22:21:54 UTC (rev 598)
+++ twittinho/model.rb	2007-06-04 01:15:49 UTC (rev 599)
@@ -1,29 +0,0 @@
-$KCODE = 'u'
-
-require 'twitter'
-
-GCONF_PATH = '/apps/twitinho/'
-
-def connect(email, password)
-	return Twitter::Base.new(email, password)
-end
-
-def readConfig (client)
-	gconfPath = GCONF_PATH
-        configs = Hash.new
-        configs[&quot;user&quot;] = client[&quot;#{gconfPath}user&quot;]
-        configs[&quot;password&quot;] = client[&quot;#{gconfPath}password&quot;]
-        configs[&quot;refresh&quot;] =  client[&quot;#{gconfPath}refresh&quot;]
-        configs[&quot;notifications&quot;] = client[&quot;#{gconfPath}notifications&quot;]
-
-        return configs
-end
-
-
-def writeConfig (client, config)
-	gconfPath = GCONF_PATH
-        client[&quot;#{gconfPath}user&quot;] = config[&quot;user&quot;]
-        client[&quot;#{gconfPath}password&quot;] = config[&quot;password&quot;]
-        client[&quot;#{gconfPath}refresh&quot;] = config[&quot;refresh&quot;].to_i
-        client[&quot;#{gconfPath}notifications&quot;] = config[&quot;notifications&quot;]
-end

Deleted: twittinho/nucleo.rb
===================================================================
--- twittinho/nucleo.rb	2007-06-03 22:21:54 UTC (rev 598)
+++ twittinho/nucleo.rb	2007-06-04 01:15:49 UTC (rev 599)
@@ -1,94 +0,0 @@
-$KCODE = 'u'
-
-require 'gtk2'
-require 'twitter'
-require 'curb'
-require 'fileutils'
-require 'model'
-
-class Nucleo
-
-	def initialize(config)
-		@connection = connect(config[&quot;user&quot;], config[&quot;password&quot;])
-		@lastStatusID = 0
-		@listStore = Gtk::ListStore.new(Gdk::Pixbuf, String)
-	end
-
-	def setLastStatusId(statusID)
-		@lastStatusID = statusID
-	end
-
-	def connection
-		@connection
-	end
-		
-	def listStore
-		@listStore
-	end
-
-	def checkNewStates
-        	return @connection.timeline(:friends)
-	end
-
-	def refreshStatuses(statusIcon, initState, config)
-        	statusesToUpdate = updateStatus
-        	if !statusesToUpdate.empty?
-        	        statusesToUpdate.each do |state|
-        	                getFaces(state.user)
-        	                insertState(state)
-        	                sendNotify(state.user, state.text, statusIcon) if config[&quot;notifications&quot;] &amp;&amp; ! initState
-        	                setLastStatusId(state.id)
-        	        end
-        	end
-	end
-
-	def updateStatus
-		newStates = checkNewStates
-		newStates = newStates.reverse!
-                statesArray = Array.new
-		newStates.each do |state|
-                	if state.id.to_i &gt; @lastStatusID.to_i
-				statesArray &lt;&lt; state
-			end
-		end
-		return statesArray
-	end
-
-	def insertState(state)
-        	## Rows are been inserted at the first position on the model. Surely it could be improved.
-        	iter = @listStore.insert(0)
-        	iter[0] = Gdk::Pixbuf.new(face(state.user.screen_name))
-        	iter[1] = state.text
-		@lastStatusID = state.id
-		#if listStore.get_iter(Gtk::TreePath.new(19))
-                #	listStore.remove(listStore.get_iter(Gtk::TreePath.new(19)))
-                #end
-
-	end
-
-	def face(twitterUser)
-		return ENV['HOME'] + '/.twitinho/images/' +  twitterUser + '.png'
-	end
-	
-	def getFaces(user)
-        	if File.exist?(face(user.screen_name))
-        	        return
-        	else
-			from = ENV['HOME'] + '/.twitinho/default_face.png'
-			FileUtils.copy(from, face(user.screen_name))
-			Thread.new do
-	        	        sleep(1)
-				url = user.profile_image_url
-        		        Curl::Easy.download(url, face(user.screen_name))
-			end
-        	end
-	end
-
-	def sendNotify(user, state, statusIcon) 
-                LibNotify.init( &quot;Twittinho&quot; )
-		test = LibNotify::Notification.new(user.name, state, face(user.screen_name), statusIcon)
-                test.timeout= 10000      # 5 seconds
-                test.show
-	end
-	
-end

Added: twittinho/setup.rb
===================================================================
--- twittinho/setup.rb	2007-06-03 22:21:54 UTC (rev 598)
+++ twittinho/setup.rb	2007-06-04 01:15:49 UTC (rev 599)
@@ -0,0 +1,1585 @@
+#
+# setup.rb
+#
+# Copyright (c) 2000-2005 Minero Aoki
+#
+# This program is free software.
+# You can distribute/modify this program under the terms of
+# the GNU LGPL, Lesser General Public License version 2.1.
+#
+
+unless Enumerable.method_defined?(:map)   # Ruby 1.4.6
+  module Enumerable
+    alias map collect
+  end
+end
+
+unless File.respond_to?(:read)   # Ruby 1.6
+  def File.read(fname)
+    open(fname) {|f|
+      return f.read
+    }
+  end
+end
+
+unless Errno.const_defined?(:ENOTEMPTY)   # Windows?
+  module Errno
+    class ENOTEMPTY
+      # We do not raise this exception, implementation is not needed.
+    end
+  end
+end
+
+def File.binread(fname)
+  open(fname, 'rb') {|f|
+    return f.read
+  }
+end
+
+# for corrupted Windows' stat(2)
+def File.dir?(path)
+  File.directory?((path[-1,1] == '/') ? path : path + '/')
+end
+
+
+class ConfigTable
+
+  include Enumerable
+
+  def initialize(rbconfig)
+    @rbconfig = rbconfig
+    @items = []
+    @table = {}
+    # options
+    @install_prefix = nil
+    @config_opt = nil
+    @verbose = true
+    @no_harm = false
+  end
+
+  attr_accessor :install_prefix
+  attr_accessor :config_opt
+
+  attr_writer :verbose
+
+  def verbose?
+    @verbose
+  end
+
+  attr_writer :no_harm
+
+  def no_harm?
+    @no_harm
+  end
+
+  def [](key)
+    lookup(key).resolve(self)
+  end
+
+  def []=(key, val)
+    lookup(key).set val
+  end
+
+  def names
+    @items.map {|i| i.name }
+  end
+
+  def each(&amp;block)
+    @items.each(&amp;block)
+  end
+
+  def key?(name)
+    @table.key?(name)
+  end
+
+  def lookup(name)
+    @table[name] or setup_rb_error &quot;no such config item: #{name}&quot;
+  end
+
+  def add(item)
+    @items.push item
+    @table[item.name] = item
+  end
+
+  def remove(name)
+    item = lookup(name)
+    @items.delete_if {|i| i.name == name }
+    @table.delete_if {|name, i| i.name == name }
+    item
+  end
+
+  def load_script(path, inst = nil)
+    if File.file?(path)
+      MetaConfigEnvironment.new(self, inst).instance_eval File.read(path), path
+    end
+  end
+
+  def savefile
+    '.config'
+  end
+
+  def load_savefile
+    begin
+      File.foreach(savefile()) do |line|
+        k, v = *line.split(/=/, 2)
+        self[k] = v.strip
+      end
+    rescue Errno::ENOENT
+      setup_rb_error $!.message + &quot;\n#{File.basename($0)} config first&quot;
+    end
+  end
+
+  def save
+    @items.each {|i| i.value }
+    File.open(savefile(), 'w') {|f|
+      @items.each do |i|
+        f.printf &quot;%s=%s\n&quot;, i.name, i.value if i.value? and i.value
+      end
+    }
+  end
+
+  def load_standard_entries
+    standard_entries(@rbconfig).each do |ent|
+      add ent
+    end
+  end
+
+  def standard_entries(rbconfig)
+    c = rbconfig
+
+    rubypath = File.join(c['bindir'], c['ruby_install_name'] + c['EXEEXT'])
+
+    major = c['MAJOR'].to_i
+    minor = c['MINOR'].to_i
+    teeny = c['TEENY'].to_i
+    version = &quot;#{major}.#{minor}&quot;
+
+    # ruby ver. &gt;= 1.4.4?
+    newpath_p = ((major &gt;= 2) or
+                 ((major == 1) and
+                  ((minor &gt;= 5) or
+                   ((minor == 4) and (teeny &gt;= 4)))))
+
+    if c['rubylibdir']
+      # V &gt; 1.6.3
+      libruby         = &quot;#{c['prefix']}/lib/ruby&quot;
+      librubyver      = c['rubylibdir']
+      librubyverarch  = c['archdir']
+      siteruby        = c['sitedir']
+      siterubyver     = c['sitelibdir']
+      siterubyverarch = c['sitearchdir']
+    elsif newpath_p
+      # 1.4.4 &lt;= V &lt;= 1.6.3
+      libruby         = &quot;#{c['prefix']}/lib/ruby&quot;
+      librubyver      = &quot;#{c['prefix']}/lib/ruby/#{version}&quot;
+      librubyverarch  = &quot;#{c['prefix']}/lib/ruby/#{version}/#{c['arch']}&quot;
+      siteruby        = c['sitedir']
+      siterubyver     = &quot;$siteruby/#{version}&quot;
+      siterubyverarch = &quot;$siterubyver/#{c['arch']}&quot;
+    else
+      # V &lt; 1.4.4
+      libruby         = &quot;#{c['prefix']}/lib/ruby&quot;
+      librubyver      = &quot;#{c['prefix']}/lib/ruby/#{version}&quot;
+      librubyverarch  = &quot;#{c['prefix']}/lib/ruby/#{version}/#{c['arch']}&quot;
+      siteruby        = &quot;#{c['prefix']}/lib/ruby/#{version}/site_ruby&quot;
+      siterubyver     = siteruby
+      siterubyverarch = &quot;$siterubyver/#{c['arch']}&quot;
+    end
+    parameterize = lambda {|path|
+      path.sub(/\A#{Regexp.quote(c['prefix'])}/, '$prefix')
+    }
+
+    if arg = c['configure_args'].split.detect {|arg| /--with-make-prog=/ =~ arg }
+      makeprog = arg.sub(/'/, '').split(/=/, 2)[1]
+    else
+      makeprog = 'make'
+    end
+
+    [
+      ExecItem.new('installdirs', 'std/site/home',
+                   'std: install under libruby; site: install under site_ruby; home: install under $HOME')\
+          {|val, table|
+            case val
+            when 'std'
+              table['rbdir'] = '$librubyver'
+              table['sodir'] = '$librubyverarch'
+            when 'site'
+              table['rbdir'] = '$siterubyver'
+              table['sodir'] = '$siterubyverarch'
+            when 'home'
+              setup_rb_error '$HOME was not set' unless ENV['HOME']
+              table['prefix'] = ENV['HOME']
+              table['rbdir'] = '$libdir/ruby'
+              table['sodir'] = '$libdir/ruby'
+            end
+          },
+      PathItem.new('prefix', 'path', c['prefix'],
+                   'path prefix of target environment'),
+      PathItem.new('bindir', 'path', parameterize.call(c['bindir']),
+                   'the directory for commands'),
+      PathItem.new('libdir', 'path', parameterize.call(c['libdir']),
+                   'the directory for libraries'),
+      PathItem.new('datadir', 'path', parameterize.call(c['datadir']),
+                   'the directory for shared data'),
+      PathItem.new('mandir', 'path', parameterize.call(c['mandir']),
+                   'the directory for man pages'),
+      PathItem.new('sysconfdir', 'path', parameterize.call(c['sysconfdir']),
+                   'the directory for system configuration files'),
+      PathItem.new('localstatedir', 'path', parameterize.call(c['localstatedir']),
+                   'the directory for local state data'),
+      PathItem.new('libruby', 'path', libruby,
+                   'the directory for ruby libraries'),
+      PathItem.new('librubyver', 'path', librubyver,
+                   'the directory for standard ruby libraries'),
+      PathItem.new('librubyverarch', 'path', librubyverarch,
+                   'the directory for standard ruby extensions'),
+      PathItem.new('siteruby', 'path', siteruby,
+          'the directory for version-independent aux ruby libraries'),
+      PathItem.new('siterubyver', 'path', siterubyver,
+                   'the directory for aux ruby libraries'),
+      PathItem.new('siterubyverarch', 'path', siterubyverarch,
+                   'the directory for aux ruby binaries'),
+      PathItem.new('rbdir', 'path', '$siterubyver',
+                   'the directory for ruby scripts'),
+      PathItem.new('sodir', 'path', '$siterubyverarch',
+                   'the directory for ruby extentions'),
+      PathItem.new('rubypath', 'path', rubypath,
+                   'the path to set to #! line'),
+      ProgramItem.new('rubyprog', 'name', rubypath,
+                      'the ruby program using for installation'),
+      ProgramItem.new('makeprog', 'name', makeprog,
+                      'the make program to compile ruby extentions'),
+      SelectItem.new('shebang', 'all/ruby/never', 'ruby',
+                     'shebang line (#!) editing mode'),
+      BoolItem.new('without-ext', 'yes/no', 'no',
+                   'does not compile/install ruby extentions')
+    ]
+  end
+  private :standard_entries
+
+  def load_multipackage_entries
+    multipackage_entries().each do |ent|
+      add ent
+    end
+  end
+
+  def multipackage_entries
+    [
+      PackageSelectionItem.new('with', 'name,name...', '', 'ALL',
+                               'package names that you want to install'),
+      PackageSelectionItem.new('without', 'name,name...', '', 'NONE',
+                               'package names that you do not want to install')
+    ]
+  end
+  private :multipackage_entries
+
+  ALIASES = {
+    'std-ruby'         =&gt; 'librubyver',
+    'stdruby'          =&gt; 'librubyver',
+    'rubylibdir'       =&gt; 'librubyver',
+    'archdir'          =&gt; 'librubyverarch',
+    'site-ruby-common' =&gt; 'siteruby',     # For backward compatibility
+    'site-ruby'        =&gt; 'siterubyver',  # For backward compatibility
+    'bin-dir'          =&gt; 'bindir',
+    'bin-dir'          =&gt; 'bindir',
+    'rb-dir'           =&gt; 'rbdir',
+    'so-dir'           =&gt; 'sodir',
+    'data-dir'         =&gt; 'datadir',
+    'ruby-path'        =&gt; 'rubypath',
+    'ruby-prog'        =&gt; 'rubyprog',
+    'ruby'             =&gt; 'rubyprog',
+    'make-prog'        =&gt; 'makeprog',
+    'make'             =&gt; 'makeprog'
+  }
+
+  def fixup
+    ALIASES.each do |ali, name|
+      @table[ali] = @table[name]
+    end
+    @items.freeze
+    @table.freeze
+    @options_re = /\A--(#{@table.keys.join('|')})(?:=(.*))?\z/
+  end
+
+  def parse_opt(opt)
+    m = @options_re.match(opt) or setup_rb_error &quot;config: unknown option #{opt}&quot;
+    m.to_a[1,2]
+  end
+
+  def dllext
+    @rbconfig['DLEXT']
+  end
+
+  def value_config?(name)
+    lookup(name).value?
+  end
+
+  class Item
+    def initialize(name, template, default, desc)
+      @name = name.freeze
+      @template = template
+      @value = default
+      @default = default
+      @description = desc
+    end
+
+    attr_reader :name
+    attr_reader :description
+
+    attr_accessor :default
+    alias help_default default
+
+    def help_opt
+      &quot;--#{@name}=#{@template}&quot;
+    end
+
+    def value?
+      true
+    end
+
+    def value
+      @value
+    end
+
+    def resolve(table)
+      @value.gsub(%r&lt;\$([^/]+)&gt;) { table[$1] }
+    end
+
+    def set(val)
+      @value = check(val)
+    end
+
+    private
+
+    def check(val)
+      setup_rb_error &quot;config: --#{name} requires argument&quot; unless val
+      val
+    end
+  end
+
+  class BoolItem &lt; Item
+    def config_type
+      'bool'
+    end
+
+    def help_opt
+      &quot;--#{@name}&quot;
+    end
+
+    private
+
+    def check(val)
+      return 'yes' unless val
+      case val
+      when /\Ay(es)?\z/i, /\At(rue)?\z/i then 'yes'
+      when /\An(o)?\z/i, /\Af(alse)\z/i  then 'no'
+      else
+        setup_rb_error &quot;config: --#{@name} accepts only yes/no for argument&quot;
+      end
+    end
+  end
+
+  class PathItem &lt; Item
+    def config_type
+      'path'
+    end
+
+    private
+
+    def check(path)
+      setup_rb_error &quot;config: --#{@name} requires argument&quot;  unless path
+      path[0,1] == '$' ? path : File.expand_path(path)
+    end
+  end
+
+  class ProgramItem &lt; Item
+    def config_type
+      'program'
+    end
+  end
+
+  class SelectItem &lt; Item
+    def initialize(name, selection, default, desc)
+      super
+      @ok = selection.split('/')
+    end
+
+    def config_type
+      'select'
+    end
+
+    private
+
+    def check(val)
+      unless @ok.include?(val.strip)
+        setup_rb_error &quot;config: use --#{@name}=#{@template} (#{val})&quot;
+      end
+      val.strip
+    end
+  end
+
+  class ExecItem &lt; Item
+    def initialize(name, selection, desc, &amp;block)
+      super name, selection, nil, desc
+      @ok = selection.split('/')
+      @action = block
+    end
+
+    def config_type
+      'exec'
+    end
+
+    def value?
+      false
+    end
+
+    def resolve(table)
+      setup_rb_error &quot;$#{name()} wrongly used as option value&quot;
+    end
+
+    undef set
+
+    def evaluate(val, table)
+      v = val.strip.downcase
+      unless @ok.include?(v)
+        setup_rb_error &quot;invalid option --#{@name}=#{val} (use #{@template})&quot;
+      end
+      @action.call v, table
+    end
+  end
+
+  class PackageSelectionItem &lt; Item
+    def initialize(name, template, default, help_default, desc)
+      super name, template, default, desc
+      @help_default = help_default
+    end
+
+    attr_reader :help_default
+
+    def config_type
+      'package'
+    end
+
+    private
+
+    def check(val)
+      unless File.dir?(&quot;packages/#{val}&quot;)
+        setup_rb_error &quot;config: no such package: #{val}&quot;
+      end
+      val
+    end
+  end
+
+  class MetaConfigEnvironment
+    def initialize(config, installer)
+      @config = config
+      @installer = installer
+    end
+
+    def config_names
+      @config.names
+    end
+
+    def config?(name)
+      @config.key?(name)
+    end
+
+    def bool_config?(name)
+      @config.lookup(name).config_type == 'bool'
+    end
+
+    def path_config?(name)
+      @config.lookup(name).config_type == 'path'
+    end
+
+    def value_config?(name)
+      @config.lookup(name).config_type != 'exec'
+    end
+
+    def add_config(item)
+      @config.add item
+    end
+
+    def add_bool_config(name, default, desc)
+      @config.add BoolItem.new(name, 'yes/no', default ? 'yes' : 'no', desc)
+    end
+
+    def add_path_config(name, default, desc)
+      @config.add PathItem.new(name, 'path', default, desc)
+    end
+
+    def set_config_default(name, default)
+      @config.lookup(name).default = default
+    end
+
+    def remove_config(name)
+      @config.remove(name)
+    end
+
+    # For only multipackage
+    def packages
+      raise '[setup.rb fatal] multi-package metaconfig API packages() called for single-package; contact application package vendor' unless @installer
+      @installer.packages
+    end
+
+    # For only multipackage
+    def declare_packages(list)
+      raise '[setup.rb fatal] multi-package metaconfig API declare_packages() called for single-package; contact application package vendor' unless @installer
+      @installer.packages = list
+    end
+  end
+
+end   # class ConfigTable
+
+
+# This module requires: #verbose?, #no_harm?
+module FileOperations
+
+  def mkdir_p(dirname, prefix = nil)
+    dirname = prefix + File.expand_path(dirname) if prefix
+    $stderr.puts &quot;mkdir -p #{dirname}&quot; if verbose?
+    return if no_harm?
+
+    # Does not check '/', it's too abnormal.
+    dirs = File.expand_path(dirname).split(%r&lt;(?=/)&gt;)
+    if /\A[a-z]:\z/i =~ dirs[0]
+      disk = dirs.shift
+      dirs[0] = disk + dirs[0]
+    end
+    dirs.each_index do |idx|
+      path = dirs[0..idx].join('')
+      Dir.mkdir path unless File.dir?(path)
+    end
+  end
+
+  def rm_f(path)
+    $stderr.puts &quot;rm -f #{path}&quot; if verbose?
+    return if no_harm?
+    force_remove_file path
+  end
+
+  def rm_rf(path)
+    $stderr.puts &quot;rm -rf #{path}&quot; if verbose?
+    return if no_harm?
+    remove_tree path
+  end
+
+  def remove_tree(path)
+    if File.symlink?(path)
+      remove_file path
+    elsif File.dir?(path)
+      remove_tree0 path
+    else
+      force_remove_file path
+    end
+  end
+
+  def remove_tree0(path)
+    Dir.foreach(path) do |ent|
+      next if ent == '.'
+      next if ent == '..'
+      entpath = &quot;#{path}/#{ent}&quot;
+      if File.symlink?(entpath)
+        remove_file entpath
+      elsif File.dir?(entpath)
+        remove_tree0 entpath
+      else
+        force_remove_file entpath
+      end
+    end
+    begin
+      Dir.rmdir path
+    rescue Errno::ENOTEMPTY
+      # directory may not be empty
+    end
+  end
+
+  def move_file(src, dest)
+    force_remove_file dest
+    begin
+      File.rename src, dest
+    rescue
+      File.open(dest, 'wb') {|f|
+        f.write File.binread(src)
+      }
+      File.chmod File.stat(src).mode, dest
+      File.unlink src
+    end
+  end
+
+  def force_remove_file(path)
+    begin
+      remove_file path
+    rescue
+    end
+  end
+
+  def remove_file(path)
+    File.chmod 0777, path
+    File.unlink path
+  end
+
+  def install(from, dest, mode, prefix = nil)
+    $stderr.puts &quot;install #{from} #{dest}&quot; if verbose?
+    return if no_harm?
+
+    realdest = prefix ? prefix + File.expand_path(dest) : dest
+    realdest = File.join(realdest, File.basename(from)) if File.dir?(realdest)
+    str = File.binread(from)
+    if diff?(str, realdest)
+      verbose_off {
+        rm_f realdest if File.exist?(realdest)
+      }
+      File.open(realdest, 'wb') {|f|
+        f.write str
+      }
+      File.chmod mode, realdest
+
+      File.open(&quot;#{objdir_root()}/InstalledFiles&quot;, 'a') {|f|
+        if prefix
+          f.puts realdest.sub(prefix, '')
+        else
+          f.puts realdest
+        end
+      }
+    end
+  end
+
+  def diff?(new_content, path)
+    return true unless File.exist?(path)
+    new_content != File.binread(path)
+  end
+
+  def command(*args)
+    $stderr.puts args.join(' ') if verbose?
+    system(*args) or raise RuntimeError,
+        &quot;system(#{args.map{|a| a.inspect }.join(' ')}) failed&quot;
+  end
+
+  def ruby(*args)
+    command config('rubyprog'), *args
+  end
+  
+  def make(task = nil)
+    command(*[config('makeprog'), task].compact)
+  end
+
+  def extdir?(dir)
+    File.exist?(&quot;#{dir}/MANIFEST&quot;) or File.exist?(&quot;#{dir}/extconf.rb&quot;)
+  end
+
+  def files_of(dir)
+    Dir.open(dir) {|d|
+      return d.select {|ent| File.file?(&quot;#{dir}/#{ent}&quot;) }
+    }
+  end
+
+  DIR_REJECT = %w( . .. CVS SCCS RCS CVS.adm .svn )
+
+  def directories_of(dir)
+    Dir.open(dir) {|d|
+      return d.select {|ent| File.dir?(&quot;#{dir}/#{ent}&quot;) } - DIR_REJECT
+    }
+  end
+
+end
+
+
+# This module requires: #srcdir_root, #objdir_root, #relpath
+module HookScriptAPI
+
+  def get_config(key)
+    @config[key]
+  end
+
+  alias config get_config
+
+  # obsolete: use metaconfig to change configuration
+  def set_config(key, val)
+    @config[key] = val
+  end
+
+  #
+  # srcdir/objdir (works only in the package directory)
+  #
+
+  def curr_srcdir
+    &quot;#{srcdir_root()}/#{relpath()}&quot;
+  end
+
+  def curr_objdir
+    &quot;#{objdir_root()}/#{relpath()}&quot;
+  end
+
+  def srcfile(path)
+    &quot;#{curr_srcdir()}/#{path}&quot;
+  end
+
+  def srcexist?(path)
+    File.exist?(srcfile(path))
+  end
+
+  def srcdirectory?(path)
+    File.dir?(srcfile(path))
+  end
+  
+  def srcfile?(path)
+    File.file?(srcfile(path))
+  end
+
+  def srcentries(path = '.')
+    Dir.open(&quot;#{curr_srcdir()}/#{path}&quot;) {|d|
+      return d.to_a - %w(. ..)
+    }
+  end
+
+  def srcfiles(path = '.')
+    srcentries(path).select {|fname|
+      File.file?(File.join(curr_srcdir(), path, fname))
+    }
+  end
+
+  def srcdirectories(path = '.')
+    srcentries(path).select {|fname|
+      File.dir?(File.join(curr_srcdir(), path, fname))
+    }
+  end
+
+end
+
+
+class ToplevelInstaller
+
+  Version   = '3.4.1'
+  Copyright = 'Copyright (c) 2000-2005 Minero Aoki'
+
+  TASKS = [
+    [ 'all',      'do config, setup, then install' ],
+    [ 'config',   'saves your configurations' ],
+    [ 'show',     'shows current configuration' ],
+    [ 'setup',    'compiles ruby extentions and others' ],
+    [ 'install',  'installs files' ],
+    [ 'test',     'run all tests in test/' ],
+    [ 'clean',    &quot;does `make clean' for each extention&quot; ],
+    [ 'distclean',&quot;does `make distclean' for each extention&quot; ]
+  ]
+
+  def ToplevelInstaller.invoke
+    config = ConfigTable.new(load_rbconfig())
+    config.load_standard_entries
+    config.load_multipackage_entries if multipackage?
+    config.fixup
+    klass = (multipackage?() ? ToplevelInstallerMulti : ToplevelInstaller)
+    klass.new(File.dirname($0), config).invoke
+  end
+
+  def ToplevelInstaller.multipackage?
+    File.dir?(File.dirname($0) + '/packages')
+  end
+
+  def ToplevelInstaller.load_rbconfig
+    if arg = ARGV.detect {|arg| /\A--rbconfig=/ =~ arg }
+      ARGV.delete(arg)
+      load File.expand_path(arg.split(/=/, 2)[1])
+      $&quot;.push 'rbconfig.rb'
+    else
+      require 'rbconfig'
+    end
+    ::Config::CONFIG
+  end
+
+  def initialize(ardir_root, config)
+    @ardir = File.expand_path(ardir_root)
+    @config = config
+    # cache
+    @valid_task_re = nil
+  end
+
+  def config(key)
+    @config[key]
+  end
+
+  def inspect
+    &quot;#&lt;#{self.class} #{__id__()}&gt;&quot;
+  end
+
+  def invoke
+    run_metaconfigs
+    case task = parsearg_global()
+    when nil, 'all'
+      parsearg_config
+      init_installers
+      exec_config
+      exec_setup
+      exec_install
+    else
+      case task
+      when 'config', 'test'
+        ;
+      when 'clean', 'distclean'
+        @config.load_savefile if File.exist?(@config.savefile)
+      else
+        @config.load_savefile
+      end
+      __send__ &quot;parsearg_#{task}&quot;
+      init_installers
+      __send__ &quot;exec_#{task}&quot;
+    end
+  end
+  
+  def run_metaconfigs
+    @config.load_script &quot;#{@ardir}/metaconfig&quot;
+  end
+
+  def init_installers
+    @installer = Installer.new(@config, @ardir, File.expand_path('.'))
+  end
+
+  #
+  # Hook Script API bases
+  #
+
+  def srcdir_root
+    @ardir
+  end
+
+  def objdir_root
+    '.'
+  end
+
+  def relpath
+    '.'
+  end
+
+  #
+  # Option Parsing
+  #
+
+  def parsearg_global
+    while arg = ARGV.shift
+      case arg
+      when /\A\w+\z/
+        setup_rb_error &quot;invalid task: #{arg}&quot; unless valid_task?(arg)
+        return arg
+      when '-q', '--quiet'
+        @config.verbose = false
+      when '--verbose'
+        @config.verbose = true
+      when '--help'
+        print_usage $stdout
+        exit 0
+      when '--version'
+        puts &quot;#{File.basename($0)} version #{Version}&quot;
+        exit 0
+      when '--copyright'
+        puts Copyright
+        exit 0
+      else
+        setup_rb_error &quot;unknown global option '#{arg}'&quot;
+      end
+    end
+    nil
+  end
+
+  def valid_task?(t)
+    valid_task_re() =~ t
+  end
+
+  def valid_task_re
+    @valid_task_re ||= /\A(?:#{TASKS.map {|task,desc| task }.join('|')})\z/
+  end
+
+  def parsearg_no_options
+    unless ARGV.empty?
+      task = caller(0).first.slice(%r&lt;`parsearg_(\w+)'&gt;, 1)
+      setup_rb_error &quot;#{task}: unknown options: #{ARGV.join(' ')}&quot;
+    end
+  end
+
+  alias parsearg_show       parsearg_no_options
+  alias parsearg_setup      parsearg_no_options
+  alias parsearg_test       parsearg_no_options
+  alias parsearg_clean      parsearg_no_options
+  alias parsearg_distclean  parsearg_no_options
+
+  def parsearg_config
+    evalopt = []
+    set = []
+    @config.config_opt = []
+    while i = ARGV.shift
+      if /\A--?\z/ =~ i
+        @config.config_opt = ARGV.dup
+        break
+      end
+      name, value = *@config.parse_opt(i)
+      if @config.value_config?(name)
+        @config[name] = value
+      else
+        evalopt.push [name, value]
+      end
+      set.push name
+    end
+    evalopt.each do |name, value|
+      @config.lookup(name).evaluate value, @config
+    end
+    # Check if configuration is valid
+    set.each do |n|
+      @config[n] if @config.value_config?(n)
+    end
+  end
+
+  def parsearg_install
+    @config.no_harm = false
+    @config.install_prefix = ''
+    while a = ARGV.shift
+      case a
+      when '--no-harm'
+        @config.no_harm = true
+      when /\A--prefix=/
+        path = a.split(/=/, 2)[1]
+        path = File.expand_path(path) unless path[0,1] == '/'
+        @config.install_prefix = path
+      else
+        setup_rb_error &quot;install: unknown option #{a}&quot;
+      end
+    end
+  end
+
+  def print_usage(out)
+    out.puts 'Typical Installation Procedure:'
+    out.puts &quot;  $ ruby #{File.basename $0} config&quot;
+    out.puts &quot;  $ ruby #{File.basename $0} setup&quot;
+    out.puts &quot;  # ruby #{File.basename $0} install (may require root privilege)&quot;
+    out.puts
+    out.puts 'Detailed Usage:'
+    out.puts &quot;  ruby #{File.basename $0} &lt;global option&gt;&quot;
+    out.puts &quot;  ruby #{File.basename $0} [&lt;global options&gt;] &lt;task&gt; [&lt;task options&gt;]&quot;
+
+    fmt = &quot;  %-24s %s\n&quot;
+    out.puts
+    out.puts 'Global options:'
+    out.printf fmt, '-q,--quiet',   'suppress message outputs'
+    out.printf fmt, '   --verbose', 'output messages verbosely'
+    out.printf fmt, '   --help',    'print this message'
+    out.printf fmt, '   --version', 'print version and quit'
+    out.printf fmt, '   --copyright',  'print copyright and quit'
+    out.puts
+    out.puts 'Tasks:'
+    TASKS.each do |name, desc|
+      out.printf fmt, name, desc
+    end
+
+    fmt = &quot;  %-24s %s [%s]\n&quot;
+    out.puts
+    out.puts 'Options for CONFIG or ALL:'
+    @config.each do |item|
+      out.printf fmt, item.help_opt, item.description, item.help_default
+    end
+    out.printf fmt, '--rbconfig=path', 'rbconfig.rb to load',&quot;running ruby's&quot;
+    out.puts
+    out.puts 'Options for INSTALL:'
+    out.printf fmt, '--no-harm', 'only display what to do if given', 'off'
+    out.printf fmt, '--prefix=path',  'install path prefix', ''
+    out.puts
+  end
+
+  #
+  # Task Handlers
+  #
+
+  def exec_config
+    @installer.exec_config
+    @config.save   # must be final
+  end
+
+  def exec_setup
+    @installer.exec_setup
+  end
+
+  def exec_install
+    @installer.exec_install
+  end
+
+  def exec_test
+    @installer.exec_test
+  end
+
+  def exec_show
+    @config.each do |i|
+      printf &quot;%-20s %s\n&quot;, i.name, i.value if i.value?
+    end
+  end
+
+  def exec_clean
+    @installer.exec_clean
+  end
+
+  def exec_distclean
+    @installer.exec_distclean
+  end
+
+end   # class ToplevelInstaller
+
+
+class ToplevelInstallerMulti &lt; ToplevelInstaller
+
+  include FileOperations
+
+  def initialize(ardir_root, config)
+    super
+    @packages = directories_of(&quot;#{@ardir}/packages&quot;)
+    raise 'no package exists' if @packages.empty?
+    @root_installer = Installer.new(@config, @ardir, File.expand_path('.'))
+  end
+
+  def run_metaconfigs
+    @config.load_script &quot;#{@ardir}/metaconfig&quot;, self
+    @packages.each do |name|
+      @config.load_script &quot;#{@ardir}/packages/#{name}/metaconfig&quot;
+    end
+  end
+
+  attr_reader :packages
+
+  def packages=(list)
+    raise 'package list is empty' if list.empty?
+    list.each do |name|
+      raise &quot;directory packages/#{name} does not exist&quot;\
+              unless File.dir?(&quot;#{@ardir}/packages/#{name}&quot;)
+    end
+    @packages = list
+  end
+
+  def init_installers
+    @installers = {}
+    @packages.each do |pack|
+      @installers[pack] = Installer.new(@config,
+                                       &quot;#{@ardir}/packages/#{pack}&quot;,
+                                       &quot;packages/#{pack}&quot;)
+    end
+    with    = extract_selection(config('with'))
+    without = extract_selection(config('without'))
+    @selected = @installers.keys.select {|name|
+                  (with.empty? or with.include?(name)) \
+                      and not without.include?(name)
+                }
+  end
+
+  def extract_selection(list)
+    a = list.split(/,/)
+    a.each do |name|
+      setup_rb_error &quot;no such package: #{name}&quot;  unless @installers.key?(name)
+    end
+    a
+  end
+
+  def print_usage(f)
+    super
+    f.puts 'Inluded packages:'
+    f.puts '  ' + @packages.sort.join(' ')
+    f.puts
+  end
+
+  #
+  # Task Handlers
+  #
+
+  def exec_config
+    run_hook 'pre-config'
+    each_selected_installers {|inst| inst.exec_config }
+    run_hook 'post-config'
+    @config.save   # must be final
+  end
+
+  def exec_setup
+    run_hook 'pre-setup'
+    each_selected_installers {|inst| inst.exec_setup }
+    run_hook 'post-setup'
+  end
+
+  def exec_install
+    run_hook 'pre-install'
+    each_selected_installers {|inst| inst.exec_install }
+    run_hook 'post-install'
+  end
+
+  def exec_test
+    run_hook 'pre-test'
+    each_selected_installers {|inst| inst.exec_test }
+    run_hook 'post-test'
+  end
+
+  def exec_clean
+    rm_f @config.savefile
+    run_hook 'pre-clean'
+    each_selected_installers {|inst| inst.exec_clean }
+    run_hook 'post-clean'
+  end
+
+  def exec_distclean
+    rm_f @config.savefile
+    run_hook 'pre-distclean'
+    each_selected_installers {|inst| inst.exec_distclean }
+    run_hook 'post-distclean'
+  end
+
+  #
+  # lib
+  #
+
+  def each_selected_installers
+    Dir.mkdir 'packages' unless File.dir?('packages')
+    @selected.each do |pack|
+      $stderr.puts &quot;Processing the package `#{pack}' ...&quot; if verbose?
+      Dir.mkdir &quot;packages/#{pack}&quot; unless File.dir?(&quot;packages/#{pack}&quot;)
+      Dir.chdir &quot;packages/#{pack}&quot;
+      yield @installers[pack]
+      Dir.chdir '../..'
+    end
+  end
+
+  def run_hook(id)
+    @root_installer.run_hook id
+  end
+
+  # module FileOperations requires this
+  def verbose?
+    @config.verbose?
+  end
+
+  # module FileOperations requires this
+  def no_harm?
+    @config.no_harm?
+  end
+
+end   # class ToplevelInstallerMulti
+
+
+class Installer
+
+  FILETYPES = %w( bin lib ext data conf man )
+
+  include FileOperations
+  include HookScriptAPI
+
+  def initialize(config, srcroot, objroot)
+    @config = config
+    @srcdir = File.expand_path(srcroot)
+    @objdir = File.expand_path(objroot)
+    @currdir = '.'
+  end
+
+  def inspect
+    &quot;#&lt;#{self.class} #{File.basename(@srcdir)}&gt;&quot;
+  end
+
+  def noop(rel)
+  end
+
+  #
+  # Hook Script API base methods
+  #
+
+  def srcdir_root
+    @srcdir
+  end
+
+  def objdir_root
+    @objdir
+  end
+
+  def relpath
+    @currdir
+  end
+
+  #
+  # Config Access
+  #
+
+  # module FileOperations requires this
+  def verbose?
+    @config.verbose?
+  end
+
+  # module FileOperations requires this
+  def no_harm?
+    @config.no_harm?
+  end
+
+  def verbose_off
+    begin
+      save, @config.verbose = @config.verbose?, false
+      yield
+    ensure
+      @config.verbose = save
+    end
+  end
+
+  #
+  # TASK config
+  #
+
+  def exec_config
+    exec_task_traverse 'config'
+  end
+
+  alias config_dir_bin noop
+  alias config_dir_lib noop
+
+  def config_dir_ext(rel)
+    extconf if extdir?(curr_srcdir())
+  end
+
+  alias config_dir_data noop
+  alias config_dir_conf noop
+  alias config_dir_man noop
+
+  def extconf
+    ruby &quot;#{curr_srcdir()}/extconf.rb&quot;, *@config.config_opt
+  end
+
+  #
+  # TASK setup
+  #
+
+  def exec_setup
+    exec_task_traverse 'setup'
+  end
+
+  def setup_dir_bin(rel)
+    files_of(curr_srcdir()).each do |fname|
+      update_shebang_line &quot;#{curr_srcdir()}/#{fname}&quot;
+    end
+  end
+
+  alias setup_dir_lib noop
+
+  def setup_dir_ext(rel)
+    make if extdir?(curr_srcdir())
+  end
+
+  alias setup_dir_data noop
+  alias setup_dir_conf noop
+  alias setup_dir_man noop
+
+  def update_shebang_line(path)
+    return if no_harm?
+    return if config('shebang') == 'never'
+    old = Shebang.load(path)
+    if old
+      $stderr.puts &quot;warning: #{path}: Shebang line includes too many args.  It is not portable and your program may not work.&quot; if old.args.size &gt; 1
+      new = new_shebang(old)
+      return if new.to_s == old.to_s
+    else
+      return unless config('shebang') == 'all'
+      new = Shebang.new(config('rubypath'))
+    end
+    $stderr.puts &quot;updating shebang: #{File.basename(path)}&quot; if verbose?
+    open_atomic_writer(path) {|output|
+      File.open(path, 'rb') {|f|
+        f.gets if old   # discard
+        output.puts new.to_s
+        output.print f.read
+      }
+    }
+  end
+
+  def new_shebang(old)
+    if /\Aruby/ =~ File.basename(old.cmd)
+      Shebang.new(config('rubypath'), old.args)
+    elsif File.basename(old.cmd) == 'env' and old.args.first == 'ruby'
+      Shebang.new(config('rubypath'), old.args[1..-1])
+    else
+      return old unless config('shebang') == 'all'
+      Shebang.new(config('rubypath'))
+    end
+  end
+
+  def open_atomic_writer(path, &amp;block)
+    tmpfile = File.basename(path) + '.tmp'
+    begin
+      File.open(tmpfile, 'wb', &amp;block)
+      File.rename tmpfile, File.basename(path)
+    ensure
+      File.unlink tmpfile if File.exist?(tmpfile)
+    end
+  end
+
+  class Shebang
+    def Shebang.load(path)
+      line = nil
+      File.open(path) {|f|
+        line = f.gets
+      }
+      return nil unless /\A#!/ =~ line
+      parse(line)
+    end
+
+    def Shebang.parse(line)
+      cmd, *args = *line.strip.sub(/\A\#!/, '').split(' ')
+      new(cmd, args)
+    end
+
+    def initialize(cmd, args = [])
+      @cmd = cmd
+      @args = args
+    end
+
+    attr_reader :cmd
+    attr_reader :args
+
+    def to_s
+      &quot;#! #{@cmd}&quot; + (@args.empty? ? '' : &quot; #{@args.join(' ')}&quot;)
+    end
+  end
+
+  #
+  # TASK install
+  #
+
+  def exec_install
+    rm_f 'InstalledFiles'
+    exec_task_traverse 'install'
+  end
+
+  def install_dir_bin(rel)
+    install_files targetfiles(), &quot;#{config('bindir')}/#{rel}&quot;, 0755
+  end
+
+  def install_dir_lib(rel)
+    install_files libfiles(), &quot;#{config('rbdir')}/#{rel}&quot;, 0644
+  end
+
+  def install_dir_ext(rel)
+    return unless extdir?(curr_srcdir())
+    install_files rubyextentions('.'),
+                  &quot;#{config('sodir')}/#{File.dirname(rel)}&quot;,
+                  0555
+  end
+
+  def install_dir_data(rel)
+    install_files targetfiles(), &quot;#{config('datadir')}/#{rel}&quot;, 0644
+  end
+
+  def install_dir_conf(rel)
+    # FIXME: should not remove current config files
+    # (rename previous file to .old/.org)
+    install_files targetfiles(), &quot;#{config('sysconfdir')}/#{rel}&quot;, 0644
+  end
+
+  def install_dir_man(rel)
+    install_files targetfiles(), &quot;#{config('mandir')}/#{rel}&quot;, 0644
+  end
+
+  def install_files(list, dest, mode)
+    mkdir_p dest, @config.install_prefix
+    list.each do |fname|
+      install fname, dest, mode, @config.install_prefix
+    end
+  end
+
+  def libfiles
+    glob_reject(%w(*.y *.output), targetfiles())
+  end
+
+  def rubyextentions(dir)
+    ents = glob_select(&quot;*.#{@config.dllext}&quot;, targetfiles())
+    if ents.empty?
+      setup_rb_error &quot;no ruby extention exists: 'ruby #{$0} setup' first&quot;
+    end
+    ents
+  end
+
+  def targetfiles
+    mapdir(existfiles() - hookfiles())
+  end
+
+  def mapdir(ents)
+    ents.map {|ent|
+      if File.exist?(ent)
+      then ent                         # objdir
+      else &quot;#{curr_srcdir()}/#{ent}&quot;   # srcdir
+      end
+    }
+  end
+
+  # picked up many entries from cvs-1.11.1/src/ignore.c
+  JUNK_FILES = %w( 
+    core RCSLOG tags TAGS .make.state
+    .nse_depinfo #* .#* cvslog.* ,* .del-* *.olb
+    *~ *.old *.bak *.BAK *.orig *.rej _$* *$
+
+    *.org *.in .*
+  )
+
+  def existfiles
+    glob_reject(JUNK_FILES, (files_of(curr_srcdir()) | files_of('.')))
+  end
+
+  def hookfiles
+    %w( pre-%s post-%s pre-%s.rb post-%s.rb ).map {|fmt|
+      %w( config setup install clean ).map {|t| sprintf(fmt, t) }
+    }.flatten
+  end
+
+  def glob_select(pat, ents)
+    re = globs2re([pat])
+    ents.select {|ent| re =~ ent }
+  end
+
+  def glob_reject(pats, ents)
+    re = globs2re(pats)
+    ents.reject {|ent| re =~ ent }
+  end
+
+  GLOB2REGEX = {
+    '.' =&gt; '\.',
+    '$' =&gt; '\$',
+    '#' =&gt; '\#',
+    '*' =&gt; '.*'
+  }
+
+  def globs2re(pats)
+    /\A(?:#{
+      pats.map {|pat| pat.gsub(/[\.\$\#\*]/) {|ch| GLOB2REGEX[ch] } }.join('|')
+    })\z/
+  end
+
+  #
+  # TASK test
+  #
+
+  TESTDIR = 'test'
+
+  def exec_test
+    unless File.directory?('test')
+      $stderr.puts 'no test in this package' if verbose?
+      return
+    end
+    $stderr.puts 'Running tests...' if verbose?
+    begin
+      require 'test/unit'
+    rescue LoadError
+      setup_rb_error 'test/unit cannot loaded.  You need Ruby 1.8 or later to invoke this task.'
+    end
+    runner = Test::Unit::AutoRunner.new(true)
+    runner.to_run &lt;&lt; TESTDIR
+    runner.run
+  end
+
+  #
+  # TASK clean
+  #
+
+  def exec_clean
+    exec_task_traverse 'clean'
+    rm_f @config.savefile
+    rm_f 'InstalledFiles'
+  end
+
+  alias clean_dir_bin noop
+  alias clean_dir_lib noop
+  alias clean_dir_data noop
+  alias clean_dir_conf noop
+  alias clean_dir_man noop
+
+  def clean_dir_ext(rel)
+    return unless extdir?(curr_srcdir())
+    make 'clean' if File.file?('Makefile')
+  end
+
+  #
+  # TASK distclean
+  #
+
+  def exec_distclean
+    exec_task_traverse 'distclean'
+    rm_f @config.savefile
+    rm_f 'InstalledFiles'
+  end
+
+  alias distclean_dir_bin noop
+  alias distclean_dir_lib noop
+
+  def distclean_dir_ext(rel)
+    return unless extdir?(curr_srcdir())
+    make 'distclean' if File.file?('Makefile')
+  end
+
+  alias distclean_dir_data noop
+  alias distclean_dir_conf noop
+  alias distclean_dir_man noop
+
+  #
+  # Traversing
+  #
+
+  def exec_task_traverse(task)
+    run_hook &quot;pre-#{task}&quot;
+    FILETYPES.each do |type|
+      if type == 'ext' and config('without-ext') == 'yes'
+        $stderr.puts 'skipping ext/* by user option' if verbose?
+        next
+      end
+      traverse task, type, &quot;#{task}_dir_#{type}&quot;
+    end
+    run_hook &quot;post-#{task}&quot;
+  end
+
+  def traverse(task, rel, mid)
+    dive_into(rel) {
+      run_hook &quot;pre-#{task}&quot;
+      __send__ mid, rel.sub(%r[\A.*?(?:/|\z)], '')
+      directories_of(curr_srcdir()).each do |d|
+        traverse task, &quot;#{rel}/#{d}&quot;, mid
+      end
+      run_hook &quot;post-#{task}&quot;
+    }
+  end
+
+  def dive_into(rel)
+    return unless File.dir?(&quot;#{@srcdir}/#{rel}&quot;)
+
+    dir = File.basename(rel)
+    Dir.mkdir dir unless File.dir?(dir)
+    prevdir = Dir.pwd
+    Dir.chdir dir
+    $stderr.puts '---&gt; ' + rel if verbose?
+    @currdir = rel
+    yield
+    Dir.chdir prevdir
+    $stderr.puts '&lt;--- ' + rel if verbose?
+    @currdir = File.dirname(rel)
+  end
+
+  def run_hook(id)
+    path = [ &quot;#{curr_srcdir()}/#{id}&quot;,
+             &quot;#{curr_srcdir()}/#{id}.rb&quot; ].detect {|cand| File.file?(cand) }
+    return unless path
+    begin
+      instance_eval File.read(path), path, 1
+    rescue
+      raise if $DEBUG
+      setup_rb_error &quot;hook #{path} failed:\n&quot; + $!.message
+    end
+  end
+
+end   # class Installer
+
+
+class SetupError &lt; StandardError; end
+
+def setup_rb_error(msg)
+  raise SetupError, msg
+end
+
+if $0 == __FILE__
+  begin
+    ToplevelInstaller.invoke
+  rescue SetupError
+    raise if $DEBUG
+    $stderr.puts $!.message
+    $stderr.puts &quot;Try 'ruby #{$0} --help' for detailed usage.&quot;
+    exit 1
+  end
+end


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000310.html">[Mspace-checkins] r598 - twittinho
</A></li>
	<LI>Next message: <A HREF="000312.html">[Mspace-checkins] r600 - twittinho
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#311">[ date ]</a>
              <a href="thread.html#311">[ thread ]</a>
              <a href="subject.html#311">[ subject ]</a>
              <a href="author.html#311">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/mspace-checkins">More information about the Mspace-checkins
mailing list</a><br>
</body></html>
