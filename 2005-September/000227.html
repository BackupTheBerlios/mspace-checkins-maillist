<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Mspace-checkins] r514 - in ComponentModel/trunk/src: . ComponentModel ComponentModel/Container
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/mspace-checkins/2005-September/index.html" >
   <LINK REL="made" HREF="mailto:mspace-checkins%40lists.berlios.de?Subject=Re%3A%20%5BMspace-checkins%5D%20r514%20-%20in%20ComponentModel/trunk/src%3A%20.%20ComponentModel%20ComponentModel/Container&In-Reply-To=%3C200509262318.j8QNI2YE019505%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000226.html">
   <LINK REL="Next"  HREF="000228.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mspace-checkins] r514 - in ComponentModel/trunk/src: . ComponentModel ComponentModel/Container</H1>
    <B>N&#233;stor Salceda at BerliOS</B> 
    <A HREF="mailto:mspace-checkins%40lists.berlios.de?Subject=Re%3A%20%5BMspace-checkins%5D%20r514%20-%20in%20ComponentModel/trunk/src%3A%20.%20ComponentModel%20ComponentModel/Container&In-Reply-To=%3C200509262318.j8QNI2YE019505%40sheep.berlios.de%3E"
       TITLE="[Mspace-checkins] r514 - in ComponentModel/trunk/src: . ComponentModel ComponentModel/Container">nestor at berlios.de
       </A><BR>
    <I>Tue Sep 27 01:18:02 CEST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000226.html">[Mspace-checkins] r513 - ComponentModel/trunk/src
</A></li>
        <LI>Next message: <A HREF="000228.html">[Mspace-checkins] r515 - in ComponentModel/trunk: . src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#227">[ date ]</a>
              <a href="thread.html#227">[ thread ]</a>
              <a href="subject.html#227">[ subject ]</a>
              <a href="author.html#227">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: nestor
Date: 2005-09-27 01:17:56 +0200 (Tue, 27 Sep 2005)
New Revision: 514

Added:
   ComponentModel/trunk/src/ComponentModel/
   ComponentModel/trunk/src/ComponentModel/AssemblyInfo.cs
   ComponentModel/trunk/src/ComponentModel/ComponentAttribute.cs
   ComponentModel/trunk/src/ComponentModel/ComponentMethodAttribute.cs
   ComponentModel/trunk/src/ComponentModel/Container/
   ComponentModel/trunk/src/ComponentModel/Container/Dao/
   ComponentModel/trunk/src/ComponentModel/DefaultComponentModel.cs
   ComponentModel/trunk/src/ComponentModel/ExceptionManager/
   ComponentModel/trunk/src/ComponentModel/Exceptions/
   ComponentModel/trunk/src/ComponentModel/Factory/
   ComponentModel/trunk/src/ComponentModel/Interfaces/
   ComponentModel/trunk/src/ComponentModel/Threading/
   ComponentModel/trunk/src/ComponentModel/VO/
Removed:
   ComponentModel/trunk/src/AssemblyInfo.cs
   ComponentModel/trunk/src/ComponentAttribute.cs
   ComponentModel/trunk/src/ComponentMethodAttribute.cs
   ComponentModel/trunk/src/ComponentModel.Container.Dao/
   ComponentModel/trunk/src/ComponentModel.Container/
   ComponentModel/trunk/src/ComponentModel.ExceptionManager/
   ComponentModel/trunk/src/ComponentModel.Exceptions/
   ComponentModel/trunk/src/ComponentModel.Factory/
   ComponentModel/trunk/src/ComponentModel.Interfaces/
   ComponentModel/trunk/src/ComponentModel.Resources/
   ComponentModel/trunk/src/ComponentModel.Threading/
   ComponentModel/trunk/src/ComponentModel.VO/
   ComponentModel/trunk/src/DefaultComponentModel.cs
Log:
A?\195?\177adida la b?\195?\186squeda por sobrecarga de ejecuci?\195?\179n de casos de uso.

Redise?\195?\177o del directorio src para poder albergar otros m?\195?\179dulos, como bien por
ejemplo tests de Unidad.



Deleted: ComponentModel/trunk/src/AssemblyInfo.cs
===================================================================
--- ComponentModel/trunk/src/AssemblyInfo.cs	2005-09-26 17:08:55 UTC (rev 513)
+++ ComponentModel/trunk/src/AssemblyInfo.cs	2005-09-26 23:17:56 UTC (rev 514)
@@ -1,12 +0,0 @@
-using System.Reflection;
-using System.Runtime.CompilerServices;
-
-[assembly: AssemblyTitle(&quot;MSpace ComponentModel&quot;)]
-[assembly: AssemblyDescription(&quot;A little component model and framework to write .NET components.&quot;)]
-[assembly: AssemblyConfiguration(&quot;&quot;)]
-[assembly: AssemblyCompany(&quot;MSpace&quot;)]
-[assembly: AssemblyProduct(&quot;ComponentModel&quot;)]
-[assembly: AssemblyCopyright(&quot;2005 (C) N&#233;stor Salceda Alonso&quot;)]
-[assembly: AssemblyTrademark(&quot;&quot;)]
-[assembly: AssemblyCulture(&quot;&quot;)]
-[assembly: AssemblyVersion(&quot;0.2.*&quot;)]

Deleted: ComponentModel/trunk/src/ComponentAttribute.cs
===================================================================
--- ComponentModel/trunk/src/ComponentAttribute.cs	2005-09-26 17:08:55 UTC (rev 513)
+++ ComponentModel/trunk/src/ComponentAttribute.cs	2005-09-26 23:17:56 UTC (rev 514)
@@ -1,66 +0,0 @@
-/*
-Babuine Component Model &amp; Babuine Framework
-Copyright (C) 2005  N&#233;stor Salceda Alonso
-
-This library is free software; you can redistribute it and/or
-modify it under the terms of the GNU Lesser General Public
-License as published by the Free Software Foundation; either
-version 2.1 of the License, or (at your option) any later version.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public
-License along with this library; if not, write to the Free Software
-Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-using System;
-
-namespace ComponentModel {
-    
-    [AttributeUsage (AttributeTargets.Class,  AllowMultiple = false, Inherited = false)]
-    public class ComponentAttribute : Attribute {
-        //Campos
-        private string componentName;
-        private string exceptionManager;
-        
-        //Propiedades p&#250;blicos.
-        public string ExceptionManager {
-            get {return exceptionManager;}
-        }
-        
-        public string ComponentName {
-            get {return componentName;}
-        }
-        
-        //M&#233;todos privados.
-        private void SetExceptionManager (string exceptionManager) {
-            if (exceptionManager == null)
-                throw new Exception (&quot;Null value not allowed.&quot;);
-            if (exceptionManager.Equals (String.Empty))
-                throw new Exception (&quot;String empty not allowed.&quot;);
-            this.exceptionManager = exceptionManager;
-        }
-        
-        private void SetComponentName (string componentName) {
-            if (componentName == null) 
-                throw new Exception (&quot;Null value not allowed.&quot;);
-            if (componentName.Equals (String.Empty))
-                throw new Exception (&quot;String empty not allowed.&quot;);
-            this.componentName = componentName;
-        }
-        
-        /**
-         * Generalmente los par&#225;metros requeridos se deben pasar en el
-         * constructor, para forzar as&#237; en tiempo de compilaci&#243;n el checkeo de
-         * que el n&#250;mero es correcto.
-         */
-        public ComponentAttribute (string componentName, string exceptionManager) : base () {
-            this.SetComponentName (componentName);
-            this.SetExceptionManager (exceptionManager);
-        }
-    }
-}

Deleted: ComponentModel/trunk/src/ComponentMethodAttribute.cs
===================================================================
--- ComponentModel/trunk/src/ComponentMethodAttribute.cs	2005-09-26 17:08:55 UTC (rev 513)
+++ ComponentModel/trunk/src/ComponentMethodAttribute.cs	2005-09-26 23:17:56 UTC (rev 514)
@@ -1,66 +0,0 @@
-/*
-Babuine Component Model &amp; Babuine Framework
-Copyright (C) 2005  N&#233;stor Salceda Alonso
-
-This library is free software; you can redistribute it and/or
-modify it under the terms of the GNU Lesser General Public
-License as published by the Free Software Foundation; either
-version 2.1 of the License, or (at your option) any later version.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public
-License along with this library; if not, write to the Free Software
-Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-using System;
-
-namespace ComponentModel {
-
-    [AttributeUsage (AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
-    public class ComponentMethodAttribute : Attribute {
-        //Campos
-        private string responseName;
-        private string viewName;
-
-        //Propiedades p&#250;blicas.
-        public string ViewName {
-            get {return viewName;}
-        }
-        
-        public string ResponseName {
-            get {return responseName;}
-        }
-
-        //M&#233;todos privados.
-        private void SetViewName (string viewName) {
-            if (viewName == null)
-                throw new Exception (&quot;Null value not allowed.&quot;);
-            if (viewName.Equals (String.Empty))
-                throw new Exception (&quot;String empty not allowed.&quot;);
-            this.viewName = viewName;
-        }
-        
-        private void SetResponseName (string responseName) {
-            if (responseName == null)
-                throw new Exception (&quot;Null value not allowed.&quot;);
-            if (responseName.Equals (String.Empty))
-                throw new Exception (&quot;String empty not allowed.&quot;);
-            this.responseName = responseName;
-        }
-
-        /**
-         * Generalmente los par&#225;metros requeridos se le pasan en orden al
-         * constructor.  Los opcionales se le pasar&#225;n como propiedades.
-         */
-        public ComponentMethodAttribute (string viewName, string responseName) : base () {
-            this.SetViewName (viewName);
-            this.SetResponseName (responseName);
-        }
-        
-    }
-}

Copied: ComponentModel/trunk/src/ComponentModel/AssemblyInfo.cs (from rev 511, ComponentModel/trunk/src/AssemblyInfo.cs)

Copied: ComponentModel/trunk/src/ComponentModel/ComponentAttribute.cs (from rev 511, ComponentModel/trunk/src/ComponentAttribute.cs)

Copied: ComponentModel/trunk/src/ComponentModel/ComponentMethodAttribute.cs (from rev 511, ComponentModel/trunk/src/ComponentMethodAttribute.cs)

Copied: ComponentModel/trunk/src/ComponentModel/Container (from rev 511, ComponentModel/trunk/src/ComponentModel.Container)

Copied: ComponentModel/trunk/src/ComponentModel/Container/Dao (from rev 511, ComponentModel/trunk/src/ComponentModel.Container.Dao)

Copied: ComponentModel/trunk/src/ComponentModel/DefaultComponentModel.cs (from rev 513, ComponentModel/trunk/src/DefaultComponentModel.cs)
===================================================================
--- ComponentModel/trunk/src/DefaultComponentModel.cs	2005-09-26 17:08:55 UTC (rev 513)
+++ ComponentModel/trunk/src/ComponentModel/DefaultComponentModel.cs	2005-09-26 23:17:56 UTC (rev 514)
@@ -0,0 +1,341 @@
+/*
+Babuine Component Model &amp; Babuine Framework
+Copyright (C) 2005  N&#233;stor Salceda Alonso
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library; if not, write to the Free Software
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+using System;
+using System.Reflection;
+using ComponentModel.Interfaces;
+using ComponentModel.VO;
+using ComponentModel.Container;
+using ComponentModel.Container.Dao;
+using ComponentModel.Factory;
+using ComponentModel.ExceptionManager;
+using ComponentModel.Threading;
+using ComponentModel.Exceptions;
+using NLog;
+
+namespace ComponentModel {
+    // TODO: En los getMethodXXX --&gt; se deber&#237;a realizar tambi&#233;n una b&#250;squeda
+    // con par&#225;metros para poder permitir la sobrecarga de m&#233;todos.  Y para las
+    // respuestas nos tapar&#237;a un error muy majo :)
+    public abstract class DefaultComponentModel : IComponentModel {
+        //Logging
+        private Logger logger = LogManager.GetLogger (&quot;ComponentModel.DefaultComponentModel&quot;);
+        //Value object with information associated to component
+        private ComponentModelVO vO;
+        //Exception manager to process exceptions.
+        private IExceptionManager defaultExceptionManager;
+
+        private VirtualMethod virtualMethod;
+
+        public VirtualMethod VirtualMethod {
+            get {return virtualMethod;}
+            set {virtualMethod = value;}
+        }
+        
+        public IExceptionManager DefaultExceptionManager {
+            get {return defaultExceptionManager;}
+            set {defaultExceptionManager = value;}
+        }
+ 
+        //Properties}
+        public ComponentModelVO VO {
+            get {return vO;}
+        }
+        
+        //Ctor
+        protected DefaultComponentModel () {
+            logger.Debug (&quot;Executing ctor for: &quot; + this.GetType ().FullName);
+        }
+      
+        private Type GetTypeExceptionManager (string exceptionManagerClassName) {
+
+            //Precondition: exceptionManagerClassName != null &amp;&amp;
+            //exceptionManagerClassName != String.Empty
+            if ((exceptionManagerClassName == null) || (exceptionManagerClassName.Equals (String.Empty))) {
+                throw new ExceptionManagerNotFoundException (&quot;Null exception managerClassName.&quot;);
+            }
+            try {
+                Type type = DefaultContainerDao.Instance.GetType (exceptionManagerClassName);
+                if (type.IsSubclassOf (typeof (DefaultExceptionManager)) || (type.GetInterface (&quot;IExceptionManager&quot;) != null)) 
+                    return type;
+            }
+            catch (TypeNotFoundException ex) {
+            //PostCondition: return != null
+            //Si llega aqu&#237;, no ha encontrado el tipo del exceptionManager.
+                throw new ExceptionManagerNotFoundException (&quot;Exception Manager Can't be found in Component.&quot;);
+            }
+            return null;
+        }
+
+        // Implementaci&#243;n de referencia para obtener la sobrecarga.  No es
+        // llamada, dado que a&#250;n no ha sido testeado su funcionamiento.
+        private MethodInfo GetMethodToExecute (string methodName, object[] parameters, Type componentType) {
+            //Precondition: methodName != null &amp;&amp; methodName != String.Empty &amp;&amp;
+            //componentType != null
+            logger.Debug (&quot;Entering GetMethodToExecute.  Searching &quot; + methodName + &quot;in: &quot; + componentType.ToString ());
+            Type[] typeParam = Type.EmptyTypes;
+            if (parameters != null) {
+                typeParam = new Type[parameters.Length];
+                for (int i = 0; i &lt; typeParam.Length; i++) {
+                    typeParam[i] = parameters[i].GetType ();
+                }
+            }
+            //Busca solamente los publicos.  Cambiar el Binder puede ser un lio
+            //grande, ojo con esto.
+            MethodInfo methodInfo = componentType.GetMethod (methodName, typeParam);
+            //&#191;encontrado?
+            if (methodInfo == null) {
+                throw new MethodNotFoundException (&quot;Method to execute: &quot; + methodName + &quot; not found.&quot;);
+            }
+            else {
+                logger.Debug (&quot;Finded method to execute: &quot; + methodInfo.ToString ());
+            }
+            //Post: methodInfo != null
+            return methodInfo;
+        }
+        
+        /*
+         * Deprecated !
+         *
+         * Este m&#233;todo no soporta la b&#250;squeda mediante la sobrecarga de m&#233;todos.
+         * 
+         */ 
+        private MethodInfo GetMethodToExecute (string methodName, Type componentType) {
+            //Precondition: methodName != null &amp;&amp; methodName != String.Empty &amp;&amp;
+            //componentType != null
+            logger.Debug (&quot;Entering GetMethodToExecute. Searching: &quot; + methodName + &quot; in: &quot; + componentType.ToString ());
+            MethodInfo methodInfo = componentType.GetMethod (methodName, BindingFlags.Instance | BindingFlags.DeclaredOnly | BindingFlags.Public);
+            //Checkeamos que lo haya encontrado
+            if (methodInfo == null) {
+                throw new MethodNotFoundException (&quot;Method to execute: &quot; + methodName + &quot; not found.&quot;);
+            }
+            else {
+                logger.Debug (&quot;Finded method to execute: &quot; + methodInfo.ToString ());
+            }
+            //PostCondition: methodInfo != null
+            return methodInfo;
+        }
+
+        private MethodInfo GetMethodToExecute (string methodName, object[] parameters) {
+            return this.GetMethodToExecute (methodName, parameters, this.GetType ());
+        }
+        
+        private MethodInfo GetMethodToResponse (Type viewType, ComponentMethodAttribute componentMethodAttribute) {
+            if (componentMethodAttribute == null) {
+                throw new ResponseNotFoundException (&quot;Please set up correctly Response Attribute.&quot;);    
+            }
+            MethodInfo responseMethod = viewType.GetMethod (componentMethodAttribute.ResponseName, BindingFlags.Instance | BindingFlags.DeclaredOnly | BindingFlags.Public) ;
+            if (responseMethod == null) 
+                throw new ResponseNotFoundException (&quot;Response: &quot; + componentMethodAttribute.ResponseName + &quot; not found in: &quot; + viewType.ToString ());
+            else 
+                logger.Debug (&quot;Finded response to execute: &quot; + responseMethod.ToString () + &quot; in: &quot; + viewType.ToString ());
+            return responseMethod;
+        } 
+        
+        private void MapException (Exception exception) {
+            if (exception.InnerException is ComponentModelException) 
+                throw exception.InnerException;
+            else {
+                if (this.defaultExceptionManager == null) {
+                    Type typeManager = this.GetTypeExceptionManager (this.VO.ExceptionManagerClassName);
+                    this.defaultExceptionManager = (IExceptionManager) typeManager.GetConstructor (null).Invoke (null);
+                }
+                this.defaultExceptionManager.ProcessException (exception.InnerException);
+            }
+        }
+        
+        private Type GetViewType (string viewType) {
+            if ((viewType == null) || (viewType.Equals (String.Empty)))
+                throw new ViewNotFoundException (&quot;Please, set up attributes correctly.&quot;);
+            try {
+                Type type = DefaultContainerDao.Instance.GetType (viewType);
+                if (type.GetInterface (&quot;IViewHandler&quot;) != null)
+                    return type;
+            }
+            catch (TypeNotFoundException exception) {
+                throw new ViewNotFoundException (&quot;View&quot; + viewType + &quot;not found.&quot;);
+            }
+            return null;
+        }
+        
+        private Type GetViewType (ComponentMethodAttribute componentMethodAttribute) {
+            if (componentMethodAttribute == null)
+                throw new ViewNotFoundException (&quot;Please set up attributes correctly.&quot;);
+            return this.GetViewType (componentMethodAttribute.ViewName);
+        }
+    
+        private ComponentMethodAttribute GetComponentAttributes (MethodInfo methodInfo) {
+            //Pre: MethodInfo != null
+            if (methodInfo == null)
+                //TODO: &#191;Es buena la excepci&#243;n?
+                throw new MethodNotFoundException (&quot;Please set up attributes correctly.&quot;);
+            Attribute[] atts = (Attribute[]) methodInfo.GetCustomAttributes (typeof (ComponentMethodAttribute), true);
+            //Post: atts != null
+            if (atts[0] == null)
+                throw new MethodNotFoundException (&quot;Can't find ComponentMethodAttribute.&quot;);
+            return ((ComponentMethodAttribute)atts[0]);
+        }
+
+
+        private ResponseMethodVO ExecuteRedirectNewView (MethodInfo methodToExecute, object[] parameters, Type viewType, MethodInfo methodToResponse) {
+            ResponseMethodVO responseMethodVO = FactoryVO.Instance.CreateResponseMethodVO (); 
+            try {
+                object ret = methodToExecute.Invoke (this, parameters);
+                responseMethodVO.MethodResult = ret;
+                object obj = viewType.GetConstructor (null).Invoke (null);
+                responseMethodVO.SetExecutionSuccess (true);
+                if (VirtualMethod != null) {
+                    VirtualMethod (responseMethodVO);
+                    VirtualMethod = null;
+                }
+                methodToResponse.Invoke (obj, new object[] {responseMethodVO});
+                return responseMethodVO;
+            }
+            catch (TargetInvocationException exception) {
+                this.MapException (exception);
+            }
+            return responseMethodVO;
+        }
+
+        private ResponseMethodVO ExecuteRedirectView (MethodInfo methodToExecute, object[] parameters, IViewHandler viewHandler, MethodInfo methodToResponse) {
+            ResponseMethodVO responseMethodVO =  FactoryVO.Instance.CreateResponseMethodVO ();
+            try {
+                object ret = methodToExecute.Invoke (this, parameters);
+                responseMethodVO.MethodResult = ret;
+                responseMethodVO.SetExecutionSuccess (true);
+                if (VirtualMethod != null) {
+                    VirtualMethod (responseMethodVO);
+                    VirtualMethod = null;
+                }
+                methodToResponse.Invoke (viewHandler, new object[] {responseMethodVO});
+            }
+            catch (TargetInvocationException exception) {
+                this.MapException (exception);
+            }
+            return responseMethodVO;
+        }
+        
+        private ResponseMethodVO ExecuteNoRedirect (MethodInfo methodToExecute, object[] parameters) {
+            ResponseMethodVO responseMethodVO = FactoryVO.Instance.CreateResponseMethodVO ();
+            try {
+                object ret = methodToExecute.Invoke (this, parameters);
+                responseMethodVO.MethodResult = ret;
+                responseMethodVO.SetExecutionSuccess (true);
+                if (VirtualMethod != null) {
+                    VirtualMethod (responseMethodVO);
+                    VirtualMethod = null;
+                }
+            }
+            catch (TargetInvocationException exception) {
+                this.MapException (exception);
+            }
+            return responseMethodVO;
+        }
+        
+        /*Executor overloads*/
+        public ResponseMethodVO Execute (string methodName, object[] parameters) {
+            return this.Execute (methodName, parameters, true, null, true);
+        }
+        
+        public ResponseMethodVO Execute (string methodName, object[] parameters, bool redirect) {
+            return this.Execute (methodName, parameters, redirect, null, true);
+        }
+        
+        public ResponseMethodVO Execute (string methodName, object[] parameters, IViewHandler viewHandler) {
+            return this.Execute (methodName, parameters, true, viewHandler, true);
+        }       
+        
+        /*Executor commander !*/
+        public ResponseMethodVO Execute (string methodName, object[] parameters, bool redirect, IViewHandler viewHandler, bool block) {
+            /*Existen cosas que siempre deben de buscarse*/
+            MethodInfo methodToExecute = this.GetMethodToExecute (methodName, parameters); 
+            ComponentMethodAttribute componentMethodAttribute = this.GetComponentAttributes (methodToExecute);
+            /*Primero discernimos si es bloqueante o no lo es*/
+            if (block) {
+                //Operaciones que son bloqueantes
+                if (redirect) {
+                    MethodInfo methodToResponse ;
+                    Type viewType;
+                    if (viewHandler == null) {
+                        //FIX: A&#250;n se podria mejorar esta invocaci&#243;n.
+                        viewType = this.GetViewType (componentMethodAttribute);
+                        methodToResponse = this.GetMethodToResponse (viewType, componentMethodAttribute);
+                        return ExecuteRedirectNewView (methodToExecute, parameters, viewType, methodToResponse);
+                    }
+                    else {
+                        //Redirigimos a la que nos pide
+                        viewType = viewHandler.GetType ();
+                        methodToResponse = this.GetMethodToResponse (viewType, componentMethodAttribute);
+                        return ExecuteRedirectView (methodToExecute, parameters, viewHandler, methodToResponse);
+                    }
+                }
+                else {
+                    //No necesitamos informaci&#243;n sobre la vista, ni el response.
+                    //No se va a ejecutar.
+                    return ExecuteNoRedirect (methodToExecute, parameters);
+                }
+            }
+            else {
+                ComponentActionDispatcher componentActionDispatcher;
+                //Operaciones bloqueantes, envolver en un hilo
+                if (redirect) {
+                    MethodInfo methodToResponse;
+                    Type viewType;
+                    if (viewHandler == null) {
+                        //Exception handling &#191;&#191;
+                        viewType = this.GetViewType (componentMethodAttribute);
+                        methodToResponse = this.GetMethodToResponse (viewType, componentMethodAttribute);
+                        componentActionDispatcher = new ComponentActionDispatcher (this, methodToExecute, parameters, viewType, methodToResponse);
+                        try {
+                            componentActionDispatcher.Do ();
+                        }
+                        catch (TargetInvocationException exception) {
+                            this.MapException (exception);
+                        }
+                        return componentActionDispatcher.ResponseMethodVO;
+                    }
+                    else {
+                        viewType = viewHandler.GetType ();
+                        methodToResponse = this.GetMethodToResponse (viewType, componentMethodAttribute);
+                        componentActionDispatcher = new ComponentActionDispatcher (this, methodToExecute, parameters, viewHandler, methodToResponse);
+                        try {
+                            componentActionDispatcher.Do ();
+                        }
+                        catch (TargetInvocationException exception) {
+                            this.MapException (exception);
+                        }
+                        return componentActionDispatcher.ResponseMethodVO;
+                    }
+                }
+                else {
+                    componentActionDispatcher = new ComponentActionDispatcher (this, methodToExecute, parameters); 
+                    try {
+                        componentActionDispatcher.Do ();
+                    }
+                    catch (TargetInvocationException exception) {
+                        this.MapException (exception);
+                    }
+                    return componentActionDispatcher.ResponseMethodVO;
+                }
+            }
+            //return null;
+        }
+
+    }
+}

Copied: ComponentModel/trunk/src/ComponentModel/ExceptionManager (from rev 511, ComponentModel/trunk/src/ComponentModel.ExceptionManager)

Copied: ComponentModel/trunk/src/ComponentModel/Exceptions (from rev 511, ComponentModel/trunk/src/ComponentModel.Exceptions)

Copied: ComponentModel/trunk/src/ComponentModel/Factory (from rev 511, ComponentModel/trunk/src/ComponentModel.Factory)

Copied: ComponentModel/trunk/src/ComponentModel/Interfaces (from rev 511, ComponentModel/trunk/src/ComponentModel.Interfaces)

Copied: ComponentModel/trunk/src/ComponentModel/Threading (from rev 511, ComponentModel/trunk/src/ComponentModel.Threading)

Copied: ComponentModel/trunk/src/ComponentModel/VO (from rev 511, ComponentModel/trunk/src/ComponentModel.VO)

Deleted: ComponentModel/trunk/src/DefaultComponentModel.cs
===================================================================
--- ComponentModel/trunk/src/DefaultComponentModel.cs	2005-09-26 17:08:55 UTC (rev 513)
+++ ComponentModel/trunk/src/DefaultComponentModel.cs	2005-09-26 23:17:56 UTC (rev 514)
@@ -1,332 +0,0 @@
-/*
-Babuine Component Model &amp; Babuine Framework
-Copyright (C) 2005  N&#233;stor Salceda Alonso
-
-This library is free software; you can redistribute it and/or
-modify it under the terms of the GNU Lesser General Public
-License as published by the Free Software Foundation; either
-version 2.1 of the License, or (at your option) any later version.
-
-This library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public
-License along with this library; if not, write to the Free Software
-Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-using System;
-using System.Reflection;
-using ComponentModel.Interfaces;
-using ComponentModel.VO;
-using ComponentModel.Container;
-using ComponentModel.Container.Dao;
-using ComponentModel.Factory;
-using ComponentModel.ExceptionManager;
-using ComponentModel.Threading;
-using ComponentModel.Exceptions;
-using NLog;
-
-namespace ComponentModel {
-    // TODO: En los getMethodXXX --&gt; se deber&#237;a realizar tambi&#233;n una b&#250;squeda
-    // con par&#225;metros para poder permitir la sobrecarga de m&#233;todos.  Y para las
-    // respuestas nos tapar&#237;a un error muy majo :)
-    public abstract class DefaultComponentModel : IComponentModel {
-        //Logging
-        private Logger logger = LogManager.GetLogger (&quot;ComponentModel.DefaultComponentModel&quot;);
-        //Value object with information associated to component
-        private ComponentModelVO vO;
-        //Exception manager to process exceptions.
-        private IExceptionManager defaultExceptionManager;
-
-        private VirtualMethod virtualMethod;
-
-        public VirtualMethod VirtualMethod {
-            get {return virtualMethod;}
-            set {virtualMethod = value;}
-        }
-        
-        public IExceptionManager DefaultExceptionManager {
-            get {return defaultExceptionManager;}
-            set {defaultExceptionManager = value;}
-        }
- 
-        //Properties
-        public ComponentModelVO VO {
-            get {return vO;}
-        }
-        
-        //Ctor
-        protected DefaultComponentModel () {
-            logger.Debug (&quot;Executing ctor for: &quot; + this.GetType ().FullName);
-        }
-      
-        private Type GetTypeExceptionManager (string exceptionManagerClassName) {
-
-            //Precondition: exceptionManagerClassName != null &amp;&amp;
-            //exceptionManagerClassName != String.Empty
-            if ((exceptionManagerClassName == null) || (exceptionManagerClassName.Equals (String.Empty))) {
-                throw new ExceptionManagerNotFoundException (&quot;Null exception managerClassName.&quot;);
-            }
-            try {
-                Type type = DefaultContainerDao.Instance.GetType (exceptionManagerClassName);
-                if (type.IsSubclassOf (typeof (DefaultExceptionManager)) || (type.GetInterface (&quot;IExceptionManager&quot;) != null)) 
-                    return type;
-            }
-            catch (TypeNotFoundException ex) {
-            //PostCondition: return != null
-            //Si llega aqu&#237;, no ha encontrado el tipo del exceptionManager.
-                throw new ExceptionManagerNotFoundException (&quot;Exception Manager Can't be found in Component.&quot;);
-            }
-            return null;
-        }
-
-        // Implementaci&#243;n de referencia para obtener la sobrecarga.  No es
-        // llamada, dado que a&#250;n no ha sido testeado su funcionamiento.
-        private MethodInfo GetMethodToExecute (string methodName, object[] parameters, Type componentType) {
-            //Precondition: methodName != null &amp;&amp; methodName != String.Empty &amp;&amp;
-            //componentType != null
-            logger.Debug (&quot;Entering GetMethodToExecute.  Searching &quot; + methodName + &quot;in: &quot; + componentType.ToString ());
-            Type[] typeParam = new Type[parameters.Length];
-            for (int i = 0; i &lt; typeParam.Length; i++) {
-                typeParam[i] = parameters[i].GetType ();
-            }
-            //Busca solamente los publicos.  Cambiar el Binder puede ser un lio
-            //grande, ojo con esto.
-            MethodInfo methodInfo = componentType.GetMethod (methodName, typeParam);
-            //&#191;encontrado?
-            if (methodInfo == null) {
-                throw new MethodNotFoundException (&quot;Method to execute: &quot; + methodName + &quot; not found.&quot;);
-            }
-            else {
-                logger.Debug (&quot;Finded method to execute: &quot; + methodInfo.ToString ());
-            }
-            //Post: methodInfo != null
-            return methodInfo;
-        }
-        
-        private MethodInfo GetMethodToExecute (string methodName, Type componentType) {
-            //Precondition: methodName != null &amp;&amp; methodName != String.Empty &amp;&amp;
-            //componentType != null
-            logger.Debug (&quot;Entering GetMethodToExecute. Searching: &quot; + methodName + &quot; in: &quot; + componentType.ToString ());
-            MethodInfo methodInfo = componentType.GetMethod (methodName, BindingFlags.Instance | BindingFlags.DeclaredOnly | BindingFlags.Public);
-            //Checkeamos que lo haya encontrado
-            if (methodInfo == null) {
-                throw new MethodNotFoundException (&quot;Method to execute: &quot; + methodName + &quot; not found.&quot;);
-            }
-            else {
-                logger.Debug (&quot;Finded method to execute: &quot; + methodInfo.ToString ());
-            }
-            //PostCondition: methodInfo != null
-            return methodInfo;
-        }
-
-        private MethodInfo GetMethodToExecute (string methodName) {
-            return this.GetMethodToExecute (methodName, this.GetType ());
-        }
-        
-        private MethodInfo GetMethodToResponse (Type viewType, ComponentMethodAttribute componentMethodAttribute) {
-            if (componentMethodAttribute == null) {
-                throw new ResponseNotFoundException (&quot;Please set up correctly Response Attribute.&quot;);    
-            }
-            MethodInfo responseMethod = viewType.GetMethod (componentMethodAttribute.ResponseName, BindingFlags.Instance | BindingFlags.DeclaredOnly | BindingFlags.Public) ;
-            if (responseMethod == null) 
-                throw new ResponseNotFoundException (&quot;Response: &quot; + componentMethodAttribute.ResponseName + &quot; not found in: &quot; + viewType.ToString ());
-            else 
-                logger.Debug (&quot;Finded response to execute: &quot; + responseMethod.ToString () + &quot; in: &quot; + viewType.ToString ());
-            return responseMethod;
-        } 
-        
-        private void MapException (Exception exception) {
-            if (exception.InnerException is ComponentModelException) 
-                throw exception.InnerException;
-            else {
-                if (this.defaultExceptionManager == null) {
-                    Type typeManager = this.GetTypeExceptionManager (this.VO.ExceptionManagerClassName);
-                    this.defaultExceptionManager = (IExceptionManager) typeManager.GetConstructor (null).Invoke (null);
-                }
-                this.defaultExceptionManager.ProcessException (exception.InnerException);
-            }
-        }
-        
-        private Type GetViewType (string viewType) {
-            if ((viewType == null) || (viewType.Equals (String.Empty)))
-                throw new ViewNotFoundException (&quot;Please, set up attributes correctly.&quot;);
-            try {
-                Type type = DefaultContainerDao.Instance.GetType (viewType);
-                if (type.GetInterface (&quot;IViewHandler&quot;) != null)
-                    return type;
-            }
-            catch (TypeNotFoundException exception) {
-                throw new ViewNotFoundException (&quot;View&quot; + viewType + &quot;not found.&quot;);
-            }
-            return null;
-        }
-        
-        private Type GetViewType (ComponentMethodAttribute componentMethodAttribute) {
-            if (componentMethodAttribute == null)
-                throw new ViewNotFoundException (&quot;Please set up attributes correctly.&quot;);
-            return this.GetViewType (componentMethodAttribute.ViewName);
-        }
-    
-        private ComponentMethodAttribute GetComponentAttributes (MethodInfo methodInfo) {
-            //Pre: MethodInfo != null
-            if (methodInfo == null)
-                //TODO: &#191;Es buena la excepci&#243;n?
-                throw new MethodNotFoundException (&quot;Please set up attributes correctly.&quot;);
-            Attribute[] atts = (Attribute[]) methodInfo.GetCustomAttributes (typeof (ComponentMethodAttribute), true);
-            //Post: atts != null
-            if (atts[0] == null)
-                throw new MethodNotFoundException (&quot;Can't find ComponentMethodAttribute.&quot;);
-            return ((ComponentMethodAttribute)atts[0]);
-        }
-
-
-        private ResponseMethodVO ExecuteRedirectNewView (MethodInfo methodToExecute, object[] parameters, Type viewType, MethodInfo methodToResponse) {
-            ResponseMethodVO responseMethodVO = FactoryVO.Instance.CreateResponseMethodVO (); 
-            try {
-                object ret = methodToExecute.Invoke (this, parameters);
-                responseMethodVO.MethodResult = ret;
-                object obj = viewType.GetConstructor (null).Invoke (null);
-                responseMethodVO.SetExecutionSuccess (true);
-                if (VirtualMethod != null) {
-                    VirtualMethod (responseMethodVO);
-                    VirtualMethod = null;
-                }
-                methodToResponse.Invoke (obj, new object[] {responseMethodVO});
-                return responseMethodVO;
-            }
-            catch (TargetInvocationException exception) {
-                this.MapException (exception);
-            }
-            return responseMethodVO;
-        }
-
-        private ResponseMethodVO ExecuteRedirectView (MethodInfo methodToExecute, object[] parameters, IViewHandler viewHandler, MethodInfo methodToResponse) {
-            ResponseMethodVO responseMethodVO =  FactoryVO.Instance.CreateResponseMethodVO ();
-            try {
-                object ret = methodToExecute.Invoke (this, parameters);
-                responseMethodVO.MethodResult = ret;
-                responseMethodVO.SetExecutionSuccess (true);
-                if (VirtualMethod != null) {
-                    VirtualMethod (responseMethodVO);
-                    VirtualMethod = null;
-                }
-                methodToResponse.Invoke (viewHandler, new object[] {responseMethodVO});
-            }
-            catch (TargetInvocationException exception) {
-                this.MapException (exception);
-            }
-            return responseMethodVO;
-        }
-        
-        private ResponseMethodVO ExecuteNoRedirect (MethodInfo methodToExecute, object[] parameters) {
-            ResponseMethodVO responseMethodVO = FactoryVO.Instance.CreateResponseMethodVO ();
-            try {
-                object ret = methodToExecute.Invoke (this, parameters);
-                responseMethodVO.MethodResult = ret;
-                responseMethodVO.SetExecutionSuccess (true);
-                if (VirtualMethod != null) {
-                    VirtualMethod (responseMethodVO);
-                    VirtualMethod = null;
-                }
-            }
-            catch (TargetInvocationException exception) {
-                this.MapException (exception);
-            }
-            return responseMethodVO;
-        }
-        
-        /*Executor overloads*/
-        public ResponseMethodVO Execute (string methodName, object[] parameters) {
-            return this.Execute (methodName, parameters, true, null, true);
-        }
-        
-        public ResponseMethodVO Execute (string methodName, object[] parameters, bool redirect) {
-            return this.Execute (methodName, parameters, redirect, null, true);
-        }
-        
-        public ResponseMethodVO Execute (string methodName, object[] parameters, IViewHandler viewHandler) {
-            return this.Execute (methodName, parameters, true, viewHandler, true);
-        }       
-        
-        /*Executor commander !*/
-        public ResponseMethodVO Execute (string methodName, object[] parameters, bool redirect, IViewHandler viewHandler, bool block) {
-            /*Existen cosas que siempre deben de buscarse*/
-            MethodInfo methodToExecute = this.GetMethodToExecute (methodName); 
-            ComponentMethodAttribute componentMethodAttribute = this.GetComponentAttributes (methodToExecute);
-            /*Primero discernimos si es bloqueante o no lo es*/
-            if (block) {
-                //Operaciones que son bloqueantes
-                if (redirect) {
-                    MethodInfo methodToResponse ;
-                    Type viewType;
-                    if (viewHandler == null) {
-                        //FIX: A&#250;n se podria mejorar esta invocaci&#243;n.
-                        viewType = this.GetViewType (componentMethodAttribute);
-                        methodToResponse = this.GetMethodToResponse (viewType, componentMethodAttribute);
-                        return ExecuteRedirectNewView (methodToExecute, parameters, viewType, methodToResponse);
-                    }
-                    else {
-                        //Redirigimos a la que nos pide
-                        viewType = viewHandler.GetType ();
-                        methodToResponse = this.GetMethodToResponse (viewType, componentMethodAttribute);
-                        return ExecuteRedirectView (methodToExecute, parameters, viewHandler, methodToResponse);
-                    }
-                }
-                else {
-                    //No necesitamos informaci&#243;n sobre la vista, ni el response.
-                    //No se va a ejecutar.
-                    return ExecuteNoRedirect (methodToExecute, parameters);
-                }
-            }
-            else {
-                ComponentActionDispatcher componentActionDispatcher;
-                //Operaciones bloqueantes, envolver en un hilo
-                if (redirect) {
-                    MethodInfo methodToResponse;
-                    Type viewType;
-                    if (viewHandler == null) {
-                        //Exception handling &#191;&#191;
-                        viewType = this.GetViewType (componentMethodAttribute);
-                        methodToResponse = this.GetMethodToResponse (viewType, componentMethodAttribute);
-                        componentActionDispatcher = new ComponentActionDispatcher (this, methodToExecute, parameters, viewType, methodToResponse);
-                        try {
-                            componentActionDispatcher.Do ();
-                        }
-                        catch (TargetInvocationException exception) {
-                            this.MapException (exception);
-                        }
-                        return componentActionDispatcher.ResponseMethodVO;
-                    }
-                    else {
-                        viewType = viewHandler.GetType ();
-                        methodToResponse = this.GetMethodToResponse (viewType, componentMethodAttribute);
-                        componentActionDispatcher = new ComponentActionDispatcher (this, methodToExecute, parameters, viewHandler, methodToResponse);
-                        try {
-                            componentActionDispatcher.Do ();
-                        }
-                        catch (TargetInvocationException exception) {
-                            this.MapException (exception);
-                        }
-                        return componentActionDispatcher.ResponseMethodVO;
-                    }
-                }
-                else {
-                    componentActionDispatcher = new ComponentActionDispatcher (this, methodToExecute, parameters); 
-                    try {
-                        componentActionDispatcher.Do ();
-                    }
-                    catch (TargetInvocationException exception) {
-                        this.MapException (exception);
-                    }
-                    return componentActionDispatcher.ResponseMethodVO;
-                }
-            }
-            //return null;
-        }
-
-    }
-}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000226.html">[Mspace-checkins] r513 - ComponentModel/trunk/src
</A></li>
	<LI>Next message: <A HREF="000228.html">[Mspace-checkins] r515 - in ComponentModel/trunk: . src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#227">[ date ]</a>
              <a href="thread.html#227">[ thread ]</a>
              <a href="subject.html#227">[ subject ]</a>
              <a href="author.html#227">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/mspace-checkins">More information about the Mspace-checkins
mailing list</a><br>
</body></html>
